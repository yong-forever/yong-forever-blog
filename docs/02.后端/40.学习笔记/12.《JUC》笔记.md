---
title: 《JUC》笔记
date: 2021-07-10 11:29:46
permalink: /server/juc/
categories:
  - 后端
  - 学习笔记
tags:
  - 学习笔记
  - java 
  - 并发
  - juc
---
# 1、什么是JUC

![image-20200710113053885](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200710113053885-1639131145674.png)

java.util工具包、分类

**业务：普通的线程代码 Thread**

**Runnable** 没有返回值 效率相比 **Callable**  相对较低！



# 2、线程和进程

> 线程 进程

进程:一个程序,QQ.exe Music.exe 程序的集合;

一个进程往往可以包含多个线程,至少包含一个

java默认有2个线程 main线程 GC线程

线程:开了一个进程Typora,写字,自动保存(线程负责的)

对于java而言:Thread、Runnable、Callable

**java真的可以开启线程吗? 不行的**  

```java
public synchronized void start() {
        /**
         * This method is not invoked for the main method thread or "system"
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state "NEW".
         */
        if (threadStatus != 0)
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
        group.add(this);

        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }

    private native void start0(); //本地方法 调用底层C++ 
```



> 并发 并行

并发编程:并发 并行

并发(多线程操作同一个资源) 

- CPU 一核 ,模拟出多条线程 ,快速交替操作模拟

并行(多个人一起行走)

- CPU多核,多个线程可以同时执行 线程池



并发编程的本质:**充分利用CPU的资源**



> 线程有几个状态

```java
public enum State {
    /** 
     * Thread state for a thread which has not yet started.
     */
    NEW,//新生

    /**
     * Thread state for a runnable thread.  A thread in the runnable
     * state is executing in the Java virtual machine but it may
     * be waiting for other resources from the operating system
     * such as processor.
     */
    RUNNABLE,//运行

    /**
     * Thread state for a thread blocked waiting for a monitor lock.
     * A thread in the blocked state is waiting for a monitor lock
     * to enter a synchronized block/method or
     * reenter a synchronized block/method after calling
     * {@link Object#wait() Object.wait}.
     */
    BLOCKED,//阻塞

    /**
     * Thread state for a waiting thread.
     * A thread is in the waiting state due to calling one of the
     * following methods:
     * <ul>
     *   <li>{@link Object#wait() Object.wait} with no timeout</li>
     *   <li>{@link #join() Thread.join} with no timeout</li>
     *   <li>{@link LockSupport#park() LockSupport.park}</li>
     * </ul>
     *
     * <p>A thread in the waiting state is waiting for another thread to
     * perform a particular action.
     *
     * For example, a thread that has called <tt>Object.wait()</tt>
     * on an object is waiting for another thread to call
     * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on
     * that object. A thread that has called <tt>Thread.join()</tt>
     * is waiting for a specified thread to terminate.
     */
    WAITING,//等待

    /**
     * Thread state for a waiting thread with a specified waiting time.
     * A thread is in the timed waiting state due to calling one of
     * the following methods with a specified positive waiting time:
     * <ul>
     *   <li>{@link #sleep Thread.sleep}</li>
     *   <li>{@link Object#wait(long) Object.wait} with timeout</li>
     *   <li>{@link #join(long) Thread.join} with timeout</li>
     *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
     *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
     * </ul>
     */
    TIMED_WAITING,//超时等待

    /**
     * Thread state for a terminated thread.
     * The thread has completed execution.
     */
    TERMINATED;//终止
}
```



> wait/sleep区别

**1、来子不同的类**

wait=>Object

sleep=>Thread

**2、关于锁的释放**

wait会释放锁

sleep不会释放

**3、使用的范围是不同的**

wait必须在同步代码块中

sleep可以在任何地方

**4、释放需要捕获异常**

wait不需要捕获异常(有线程中断异常)

sleep需要捕获异常



# 3、lock 锁

> 传统 Synchronized





> Lock 

![image-20200710170035872](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200710170035872-1639131142876.png)

所有已知实现类： 

- ReentrantLock 可重入锁(常用)

  - ```java
    public ReentrantLock() {
        sync = new NonfairSync();//默认不公平锁
    }
    
    /**
     * Creates an instance of {@code ReentrantLock} with the
     * given fairness policy.
     *
     * @param fair {@code true} if this lock should use a fair ordering policy
     */
    //有参true公平锁 false不公平锁
    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
    ```

    公平锁:可以先来后到

    **非公平锁:可以插队(默认)**

-  ReentrantReadWriteLock.ReadLock 读锁

-   ReentrantReadWriteLock.WriteLock 写锁





> Synchronized 和 Lock 的区别

1. Synchronized 是内置java关键字, Lock是一个java类
2. Synchronized 无法判断获取锁得状态, Lock可以判断释放得到了锁
3. Synchronized会自动释放锁, Lock必须要手动解锁,如果不是释放锁:死锁
4. Synchronized 线程1(获得锁,如果阻塞) 线程2(等待) Lock锁就不一定会等待下去lock.trylock();
5. Synchronized 可重入锁,不可用中断非公平;Lock,可重入锁,可以判断锁,非公平(可调节)
6. Synchronized 适合锁少了的代码同步问题, Lock适合锁大量的同步代码!



> 锁是什么,如何判断锁的是谁?



# 4、生产者和消费者问题

> 生产者和消费者问题 Synchronized版

```java
public class A {
    public static void main(String[] args) {
        Data data=new Data();
        
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            },"A").start();
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            },"B").start();
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"C").start();
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"D").start();
    }
}

//资源类
//判断是否等待--->业务--->通知
class Data{

    private int number=0;

    //+1
    public synchronized void increment() throws InterruptedException {
        if(number!=0){
            //等待
            this.wait();
        }
        number++;
        //通知其他线程 +1完毕
        System.out.println(Thread.currentThread().getName()+"=>"+number);
        this.notifyAll();
    }

    //-1
    public synchronized void decrement() throws InterruptedException {
        if(number==0){
            //等待
            this.wait();
        }
        number--;
        //通知其他线程 -1完毕
        System.out.println(Thread.currentThread().getName()+"=>"+number);
        this.notifyAll();
    }
}
```

> 只有A,B没问题,但假如C ,D 总共4个线程出现问题

线程也可以唤醒，而不会被通知，中断或超时，即所谓的***虚假唤醒*** 。  虽然这在实践中很少会发生，但应用程序必须通过测试应该使线程被唤醒的条件来防范，并且如果条件不满足则继续等待。  换句话说，等待应该总是出现在循环中，就像这样： 

```
  synchronized (obj) {
         while (<condition does not hold>)
             obj.wait(timeout);
         ... // Perform action appropriate to condition
     } 
```

（有关此主题的更多信息，请参阅Doug  Lea的“Java并行编程（第二版）”（Addison-Wesley，2000）中的第3.2.3节或Joshua  Bloch的“有效Java编程语言指南”（Addison- Wesley，2001）。

如果当前线程[interrupted](../../java/lang/Thread.html#interrupt--)任何线程之前或在等待时，那么`InterruptedException`被抛出。  如上所述，在该对象的锁定状态已恢复之前，不会抛出此异常。

当前线程。  当抛出此异常时，当前线程的*中断状态*将被清除。 



**if 改为 while 判断**



> JUC版的生产者和消费者问题

通过Lock 找到 Condition

- ```java
   class BoundedBuffer {
     final Lock lock = new ReentrantLock();
     final Condition notFull  = lock.newCondition(); 
     final Condition notEmpty = lock.newCondition(); 
    
     final Object[] items = new Object[100];
     int putptr, takeptr, count;
    
     public void put(Object x) throws InterruptedException {
       lock.lock(); try {
         while (count == items.length)
           notFull.await();
         items[putptr] = x;
         if (++putptr == items.length) putptr = 0;
         ++count;
         notEmpty.signal();
       } finally { lock.unlock(); }
     }
    
     public Object take() throws InterruptedException {
       lock.lock(); try {
         while (count == 0)
           notEmpty.await();
         Object x = items[takeptr];
         if (++takeptr == items.length) takeptr = 0;
         --count;
         notFull.signal();
         return x;
       } finally { lock.unlock(); }
     }
   } 
  ```

代码实现！

```java
public class B {
    public static void main(String[] args) {
        Data2 data=new Data2();
        
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            },"A").start();
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            },"B").start();
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"C").start();
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"D").start();
    }
}

//资源类
//判断是否等待--->业务--->通知
class Data2{

    private int number=0;

    Lock lock=new ReentrantLock();

    Condition condition = lock.newCondition();


    //+1
    public void increment() throws InterruptedException {
        try {
            lock.lock();
            while (number!=0){
                //等待
                condition.await();
            }
            number++;
            //通知其他线程 +1完毕
            System.out.println(Thread.currentThread().getName()+"=>"+number);
            condition.signalAll();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    //-1
    public synchronized void decrement() throws InterruptedException {
        try {
            lock.lock();
            while (number==0){
                //等待
                condition.await();
            }
            number--;
            //通知其他线程 -1完毕
            System.out.println(Thread.currentThread().getName()+"=>"+number);
            condition.signalAll();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```

> Condition 精准的通知和唤醒线程

代码测试：

```java
public class C {
    public static void main(String[] args) {

        Data3 data3 = new Data3();


        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                data3.printOne();

            }
        }, "A").start();
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                data3.printTwo();

            }
        }, "B").start();
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                data3.printThree();

            }
        }, "C").start();
    }
}

/**
 * 按顺序执行
 */
class Data3 {//资源类 lock

    private Lock lock = new ReentrantLock();

    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private Condition condition3 = lock.newCondition();

    private int number = 1;

    public void printOne() {
        lock.lock();
        try {
            while (number != 1) {
                condition1.await();
            }
            System.out.println(Thread.currentThread().getName() + "=> One");
            //唤醒指定的 Two
            number = 2;
            condition2.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void printTwo() {
        lock.lock();
        try {
            while (number != 2) {
                condition2.await();
            }
            System.out.println(Thread.currentThread().getName() + "=> Two");
            //唤醒指定的 Three
            number = 3;
            condition3.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void printThree() {
        lock.lock();
        try {
            while (number != 3) {
                condition3.await();
            }
            System.out.println(Thread.currentThread().getName() + "=> Three");
            //唤醒指定的 One
            number = 1;
            condition1.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```



# 5、8锁现象

如何判断锁的是谁！

**深刻理解锁**

```java
/**
 * 1.标准情况下，先短信还是打电话？ 1发短信 2打电话
 * 2.sendSms延迟4s，先短信还是打电话？ 1发短信 2打电话
 * 3.sendSms延迟4s并且增加普通方法hello，先短信还是hello？ 1hello 2发短信
 * 4.两个对象两个同步方法，先短信还是打电话？ 1call 2发短信（phone.sendSms延迟4s）
 */
public class Test1 {
    public static void main(String[] args) {
        //两个对象
        Phone phone=new Phone();
        Phone phone2=new Phone();

        //锁的存在
        new Thread(()->{
            phone.sendSms();
        },"A").start();

        //点1
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        /*new Thread(()->{
            phone.call();
        },"B").start();*/


        new Thread(()->{
            phone2.call();
        },"B").start();
    }

}
class Phone{

    //synchronized 锁的对象是方法的调用者！
    //两个方法用的是同一个锁，谁先拿到先执行

    public synchronized void sendSms(){

        //点2
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("sendSms");
    }

    public synchronized void call(){
        System.out.println("call");
    }

    //点3
    //这里没有锁，不是同步方法，不受锁的影响
    public void hello(){
        System.out.println("hello");
    }
}
```

```java
/**
 * 5.改为两个静态的同步方法 后？ 1短信 2打电话
 * 6.两个对象！改为两个静态的同步方法 后？ 1短信 2打电话
 */
public class Test2 {
    public static void main(String[] args) {
        //两个对象的Class类模板只有一个,static 锁的是Class
        Phone2 phone = new Phone2();
        Phone2 phone2 = new Phone2();

        //锁的存在
        new Thread(() -> {
            phone.sendSms();
        }, "A").start();

        //点1
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            phone2.call();
        }, "B").start();
    }

}

// 类的Class对象唯一
class Phone2 {

    //synchronized 锁的对象是方法的调用者！
    //两个方法用的是同一个锁，谁先拿到先执行
    //static 静态方法
    //类一加载就有了！Class 模板 锁的是Class
    public static synchronized void sendSms() {

        //点2
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("sendSms");
    }

    public static synchronized void call() {
        System.out.println("call");
    }


}
```

```java
/**
 * 7.1个静态的同步方法，1一个普通方法，一个对象 后？ 1打电话 2短信
 * 8.两个对象！1个静态的同步方法，1一个普通方法 后？ 1打电话 2短信
 */
public class Test3 {
    public static void main(String[] args) {
        Phone3 phone = new Phone3();
        Phone3 phone2 = new Phone3();

        new Thread(() -> {
            phone.sendSms();
        }, "A").start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            phone2.call();
        }, "B").start();
    }

}

// 类的Class对象唯一
class Phone3 {

    //静态同步方法 锁的class模板
    public static synchronized void sendSms() {

        //点2
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("sendSms");
    }

    //普通同步方法 锁的 对象
    public  synchronized void call() {
        System.out.println("call");
    }


}
```

> 小结

new  this 具体的一个手机 锁对象

static Class 唯一的Class 模板 锁Class





# 6、集合类不安全

> List 不安全

```java
public class ListTest {
    public static void main(String[] args) {
        //并发下 ArrayList 不安全的
        /**
         * 解决方案：
         * 1.List<String> list = new Vector<>();
         * 2.List<String> list = Collections.synchronizedList(new ArrayList<>());
         * 3.List<String> list = new CopyOnWriteArrayList<>();
         */
        //CopyOnWrite写入时复制 COW 计算机程序设计领域的优化策略
        //多个线程调用的时候，lsit，读取的时候固定，写入可能会覆盖
        //在写入的时候避免覆盖，造成数据问题
        //读写分离 （mycat）
        //CopyOnWriteArrayList 比 Vector 好在哪里？ 
        // 在add方法里
        // Vector=>synchronized CopyOnWriteArrayList=>lock锁
        List<String> list = new CopyOnWriteArrayList<>();
        for (int i = 1; i <= 10; i++) {
            new Thread(()->{
                list.add(UUID.randomUUID().toString().substring(0,5));
                System.out.println(Thread.currentThread().getName()+":"+list);
            },String.valueOf(i)).start();
        }
    }
}
```

> Set 不安全

```java
public class SetTest {
    public static void main(String[] args) {
        //ConcurrentModificationException 同样错误
        /**
         *  解决方案：
         *  1.Set<String> set = Collections.synchronizedSet(new HashSet<>());
         *  2.Set<String> set = new CopyOnWriteArraySet();
         */
        Set<String> set = new CopyOnWriteArraySet();
        for (int i = 0; i < 100; i++) {
            new Thread(()->{
                set.add(UUID.randomUUID().toString().substring(0,5));
                System.out.println(set);
            },String.valueOf(i)).start();
        }
    }
}
```

hashSet底层是什么？

```java
public HashSet(){
	map = new HashMap<>();
}
// add set 本质就是 map key是无法重复的
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
// 伪值，以便与后备映射中的对象相关联
private static final Object PRESENT = new Object();//不变
```



> HashMap 不安全

![image-20200713172443333](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200713172443333-1639131140204.png)

```java
public class MapTest {
    public static void main(String[] args) {
        //map 是这样用的吗？ 默认等价于什么 工作不用HashMap

        // 加载因子0.75、初始化容量16 HashMap<>(16,0.75);

        /**
         * Exception in thread "29" java.util.ConcurrentModificationException
         *  解决方案：
         *  1.Map<String, String> map = Collections.synchronizedMap(new HashMap<>());
         *  2.Map<String, String> map = new ConcurrentHashMap<>();
         */

        Map<String, String> map = new ConcurrentHashMap<>();
        for (int i = 0; i < 30; i++) {
            new Thread(()->{
                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,5));
                System.out.println(map);
            },String.valueOf(i)).start();
        }
    }
}
```



# 7、Callable 

1. 可以有返回值
2. 可以抛出异常
3. 方法不同，不是run() --- 而是call()

```java
public class CallableTest {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //new Thread(new MyThread()).start();
        /**
         *  new Thread(new Runnable()).start();
         *  Runnable 实现类 FutureTask
         *  new Thread(new FutureTask<>(Callable)).start();
         */
        MyThread2 myThread2=new MyThread2();
        FutureTask futureTask = new FutureTask<>(myThread2);
        new Thread(futureTask,"A").start();
        new Thread(futureTask,"B").start();//结果会被缓存，效率高
        String s = (String) futureTask.get();// 这个get方法可能会阻塞！放到最后
        //或者通过异步通信处理
        System.out.println(s);
    }
}

class MyThread implements Runnable{

    @Override
    public void run() {
        System.out.println("run()");
    }
}

class MyThread2 implements Callable<String> {

    @Override
    public String call(){
        System.out.println("call()");
        //耗时的操作
        return "ab";
    }
}
```

**细节**

1. 有缓存
2. 结果可能需要等待，会阻塞！





# 8、常用辅助类

## 8.1、CountDownLatch

```java
//计数器
public class CountDwonLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        //总数是6
        CountDownLatch countDownLatch=new CountDownLatch(10);
        //countDownLatch.countDown();//-1

        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"-退出");
                countDownLatch.countDown();
            },String.valueOf(i)).start();
        }
        countDownLatch.await();//等待计数器归零，在向下执行
        System.out.println("OK");
    }
}
```

原理：

==countDownLatch.countDown();//数量-1==

==countDownLatch.await();//等待计数器归零，在向下执行==

每次线程调用countDown，减至0，唤醒countDownLatch.await()；执行后面语句



## 8.2、CyclicBarrier

```java
public class CyclicBarrierDemo {
    public static void main(String[] args) {
        //集齐7龙珠
        CyclicBarrier cyclicBarrier=new CyclicBarrier(7,()->{
            System.out.println("召唤神龙！");
        });
        for (int i = 1; i <= 7; i++) {
            int finalI = i;
            new Thread(()->{ 
                System.out.println(Thread.currentThread().getName()+"收集龙珠");
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            },String.valueOf(i)).start();
        }
    }
}
```

类似上面减法，这是加法



## 8.3、Semaphore

Semaphore：信号量

![image-20200715143051692](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200715143051692-1639131137671.png)

```java
public class SemaphoreDemo {
    public static void main(String[] args) {
        //线程数量：停车位 限流！
        Semaphore semaphore= new Semaphore(3);

        for (int i = 1; i <= 6; i++) {
            new Thread(()->{
                try {
                    semaphore.acquire();//得到
                    System.out.println(Thread.currentThread().getName()+" 抢到车位");
                    TimeUnit.SECONDS.sleep(2);//停2s
                    System.out.println(Thread.currentThread().getName()+" 离开车位");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    semaphore.release();//释放
                }
            },String.valueOf(i)).start();
        }
    }
}
```

原理：

==semaphore.acquire();//得到== **如果已经满了，等待其他线程释放在执行后面语句**

==semaphore.release();//释放== **将当前信号量释放，唤醒等待线程**

作用：多个共享资源互斥的使用！并发限流，控制最大线程数

# 9、读写锁

![image-20200715144338382](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200715144338382-1639131134490.png)

一个作家 多个读者

```java
/**
 * 写：独占锁 一次只能被一个线程占用
 * 读：共享锁 多个线程可以同时占有 （与写锁互斥）
 */
public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCacheLock myCache = new MyCacheLock();

        for (int i = 5; i < 10; i++) {
            int finalI = i;
            new Thread(() -> {
                myCache.get(finalI + "");
            }, String.valueOf(i)).start();
        }

        for (int i = 0; i < 5; i++) {
            int finalI = i;
            new Thread(() -> {
                myCache.put(finalI + "", finalI + "");
            }, String.valueOf(i)).start();
        }


    }
}

/**
 * 自定义缓存
 */
class MyCache {
    private volatile Map<String, Object> map = new HashMap<>();

    //存，写
    public void put(String key, Object value) {
        System.out.println(Thread.currentThread().getName() + "写入");
        map.put(key, value);
        System.out.println(Thread.currentThread().getName() + "写入完毕");
    }

    //取，读
    public Object get(String key) {
        System.out.println(Thread.currentThread().getName() + "读取");
        Object o = map.get(key);
        System.out.println(Thread.currentThread().getName() + "读取完毕");
        return o;
    }
}

class MyCacheLock {
    private volatile Map<String, Object> map = new HashMap<>();
    //读写锁，更加细粒度的操作
    private ReadWriteLock lock = new ReentrantReadWriteLock();

    //存，写入的时候，只希望同时只要一个线程写
    public void put(String key, Object value) {
        lock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + "写入");
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + "写入完毕");
        } finally {
            lock.writeLock().unlock();
        }
    }

    //取，读，所有人都可以读
    public Object get(String key) {
        lock.readLock().lock();
        Object o;
        try {
            System.out.println(Thread.currentThread().getName() + "读取");
            o = map.get(key);
            System.out.println(Thread.currentThread().getName() + "读取完毕");
        } finally {
            lock.readLock().unlock();
        }
        return o;
    }
}
```

**细节**

- 读写锁互斥，读的时候写不会执行，写的时候读不会执行



# 10、阻塞队列

阻塞：写入时队列满了，就必须阻塞等待，如果队列为空，必须阻塞等待生产

队列

**BlockingQueue**

什么情况下我们会使用 阻塞队列：多线程并发处理，线程池

| 方式       | 抛出异常  | 有返回值 | 阻塞等待 | 超时等待  |
| ---------- | --------- | -------- | -------- | --------- |
| 添加       | add()     | offer()  | put()    | offer(,,) |
| 移除       | remove()  | poll()   | take()   | poll(,)   |
| 判断队列首 | element() | peek()   | -        | -         |

```java
/**
 * 抛出异常
 */
public static void test1(){
    //队列的大小
    ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);
    System.out.println(blockingQueue.add("a"));
    System.out.println(blockingQueue.add("b"));
    System.out.println(blockingQueue.add("c"));



    //在添加一个抛出异常
    // Exception in thread "main" java.lang.IllegalStateException: Queue full
    //System.out.println(blockingQueue.add("d"));

    System.out.println(blockingQueue.remove());
    //System.out.println(blockingQueue.element());//查看队首元素
    System.out.println(blockingQueue.remove());
    System.out.println(blockingQueue.remove());

    //空移除抛出异常
    //Exception in thread "main" java.util.NoSuchElementException
    //System.out.println(blockingQueue.remove());
}
```

```java
/**
 * 有返回值
 */
public static void test2(){
   //队列的大小
   ArrayBlockingQueue blockingQueue=new ArrayBlockingQueue(3);

    System.out.println(blockingQueue.offer("a"));
    System.out.println(blockingQueue.offer("b"));
    System.out.println(blockingQueue.offer("c"));

    //flase 不抛出异常
    System.out.println(blockingQueue.offer("d"));

    System.out.println(blockingQueue.poll());
    System.out.println(blockingQueue.peek());
    System.out.println(blockingQueue.poll());
    System.out.println(blockingQueue.poll());

    //null 不抛出异常
    System.out.println(blockingQueue.poll());


}
```

```java
/**
 * 等待，阻塞（一直阻塞）
 */
public static void test3() throws InterruptedException {
    //队列的大小
    ArrayBlockingQueue blockingQueue=new ArrayBlockingQueue(3);

    blockingQueue.put("a");
    blockingQueue.put("b");
    blockingQueue.put("c");

    //没有位置一直等待
    //blockingQueue.put("d");

    System.out.println(blockingQueue.take());
    System.out.println(blockingQueue.take());
    System.out.println(blockingQueue.take());

    //没有东西一直等待
    //System.out.println(blockingQueue.take());
}
```

```java
/**
 * 等待，阻塞（超时等待）
 */
public static void test4() throws InterruptedException {
    //队列的大小
    ArrayBlockingQueue blockingQueue=new ArrayBlockingQueue(3);

    System.out.println(blockingQueue.offer("a"));
    System.out.println(blockingQueue.offer("b"));
    System.out.println(blockingQueue.offer("c"));

    //没有位置 2s后就不等了
    System.out.println(blockingQueue.offer("d", 2, TimeUnit.SECONDS));

    System.out.println(blockingQueue.poll());
    System.out.println(blockingQueue.poll());
    System.out.println(blockingQueue.poll());
    //等待2s后不等
    System.out.println(blockingQueue.poll(2, TimeUnit.SECONDS));

}
```



> SynchronousQueue 同步队列

进去一个元素，必须等待取出来之后，才能往里面放一个元素！

put,take

```java
/**
 * 同步队列
 * 和其他的BlockingQueue 不一样
 * put了一个元素，必须take出来，否则不能再put
 */
public class SynchronousQueueDemo {
    public static void main(String[] args) {
        SynchronousQueue<String> synchronousQueue = new SynchronousQueue<>();

        new Thread(()->{
            try {
                System.out.println(Thread.currentThread().getName()+" put 1");
                synchronousQueue.put("1");
                System.out.println(Thread.currentThread().getName()+" put 2");
                synchronousQueue.put("2");
                System.out.println(Thread.currentThread().getName()+" put 3");
                synchronousQueue.put("3");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"t1").start();

        new Thread(()->{
            try {
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName()+" take "+synchronousQueue.take());
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName()+" take "+synchronousQueue.take());
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName()+" take "+synchronousQueue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"t2").start();
    }
}
```



# 11、线程池（重点）

线程池：三大方法，7大参数，4种拒绝策略

> 池化技术

程序的运行，本质：占用系统的资源！优化资源的使用！=>池化技术

线程池、连接池、内存池、对象池...//创建销毁。十分浪费资源

池化技术：实现准备好一些资源，有人要用就直接拿，用完归还



**线程池的好处：**

1. 降低资源的消耗
2. 提高响应速度
3. 方便管理

==线程复用、控制最大并发数、管理线程==



> 线程池：三个方法

```java
//Executors 工具类、三大方法
//使用线程池来创建线程
public class Demo1 {
    public static void main(String[] args) {
        //最大线程如何定义
        //1、CPU 密集型 几核就定义几 可以保持CPU效率最高 12条线程同时运行
        //2、IO 密集型 判断程序中十分耗IO的线程，多加

        //ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程
        //ExecutorService threadPool = Executors.newFixedThreadPool(5);//创建固定线程池的大小
        //ExecutorService threadPool = Executors.newCachedThreadPool();//可伸缩的，遇强则强，遇弱则弱

        //自定义线程池
        //最大承载 队列+max
        ExecutorService threadPool = new ThreadPoolExecutor(
                2,
                5,//Runtime.getRuntime().availableProcessors() CPU 密集型
                3,
                TimeUnit.SECONDS,
                new LinkedBlockingDeque<>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.DiscardOldestPolicy());
        ////new ThreadPoolExecutor.AbortPolicy()策略：满了，还有人来，不处理这个人抛出异常
        ////new ThreadPoolExecutor.CallerRunsPolicy()策略：满了，哪里来回哪去（打发人）
        ////new ThreadPoolExecutor.DiscardPolicy()策略：满了，不处理不抛出异常
        ////new ThreadPoolExecutor.DiscardOldestPolicy()策略：满了，尝试去和最早的竞争不抛出异常。


        try {

            for (int i = 0; i < 10; i++) {
                //new Thread(()->{}).start(); 老方法
                threadPool.execute(() -> {
                    System.out.println(Thread.currentThread().getName() + " ok");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //用完关闭线程池
            threadPool.shutdown();
        }
    }
}

```

>七大参数

```java
public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }


public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }

public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }

//本质 new ThreadPoolExecutor()
public ThreadPoolExecutor(int corePoolSize,//核心线程池大小
                              int maximumPoolSize,//最大核心线程池大小
                              long keepAliveTime,//超时无人使用释放
                              TimeUnit unit,//超市单位
                              BlockingQueue<Runnable> workQueue,//阻塞队列
                              ThreadFactory threadFactory,//线程工厂
                              RejectedExecutionHandler handler//拒绝策略) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```









# 12、四大函数式接口(掌握)

lambda表达式、链式编程、函数式接口、Stream流式计算

> 函数式接口：只有一个方法的接口

```java
@FunctionalInterface
public interface Runnable {

    public abstract void run();
}
//泛型、枚举、反射
//lambda表达式、链式编程、函数式接口、Stream流式计算
//超级多@FunctionalInterface
//简化编程模型，在新版本的框架底层大量应用
//foreach（消费者类的函数式接口）
```



**四大函数式**接口

- Function 函数型接口
- Predicate 断定型接口
- Consumer 消费型接口
- Supplier 供给型接口

```java
/**
 * Function 函数型接口,有一个输入，有一个输出
 */
public class Demo1 {
    public static void main(String[] args) {
        //工具类：输出输入的值
        /*Function function = new Function<String,String>() {

            @Override
            public String apply(String s) {
                return s;
            }
        };*/

        //lambda
        //Function function =(str)->{return str};
        Function<String,String> function =str->str;


        System.out.println(function.apply("11"));
    }
}
```

```java
/**
 * Predicate 断定型接口：有一个输入参数，返回值只能是布尔值！
 */
public class Demo2 {
    public static void main(String[] args) {
        //判断字符串是否为空
        /*Predicate predicate = new Predicate<String>() {
            @Override
            public boolean test(String s) {
                return s.isEmpty();
            }
        };*/

        Predicate<String> predicate =(str)->{return str.isEmpty();};

        System.out.println(predicate.test(""));
    }
}
```

```java
/**
 * Consumer 消费型接口 只有输入，没有返回值
 */
public class Demo3 {
    public static void main(String[] args) {
        /*Consumer<String> consumer=new Consumer<String>() {
            @Override
            public void accept(String s) {
                System.out.println(s);
            }
        };*/

        Consumer<String> consumer=(str)->{
            System.out.println(str);
        };

        consumer.accept("as");
    }
}
```

```java
/**
 * Supplier 供给型接口 没有参数，只有返回值
 */
public class Demo4 {
    public static void main(String[] args) {
        /*Supplier<String> supplier=new Supplier<String>() {
            @Override
            public String get() {
                return "hello";
            }
        };*/

        Supplier<String> supplier=()->{return "hello";};

        System.out.println(supplier.get());
    }
}
```



# 13、流式计算

> 什么是Stream流式计算

大数据：存储+计算

集合、Mysql本质就是存储东西

计算应该都交给流来做！

```java
/**
 * 题目要求：一分钟完成磁体，用一行代码实现！
 * 现在5个用户！筛选：
 * 1、ID必须是偶数
 * 2、年龄大于23岁
 * 3、用户名转大写
 * 4、用户名字母倒序
 * 5、只输出一个用户
 */
public class Test {
    public static void main(String[] args) {
        User u1=new User(1,"a",21);
        User u2=new User(2,"b",22);
        User u3=new User(3,"c",23);
        User u4=new User(4,"d",24);
        User u5=new User(5,"e",25);
        User u6=new User(6,"f",27);
        //集合就是存储
        List<User> list=Arrays.asList(u1,u2,u3,u4,u5,u6);

        //计算交给Stream流
        list.stream()
                .filter((u)->{return u.getId()%2==0;})//泛型<User>
                .filter((u)->{return u.getAge()>23;})//泛型<User>
                .map((u)->{return u.getName().toUpperCase();})//泛型<String>
                .sorted((uu1,uu2)->{return uu2.compareTo(uu1);})//泛型<String>
                .limit(1)
                .forEach(System.out::println);
    }
}
```



# 14、ForkJoin

> 什么是ForkJoin

ForkJoin再JDK1.7，并行执行任务！提高效率。大数据量！

大数据：Map Reduce（把大任务拆分为小任务）

![image-20200716152709374](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200716152709374-1639131130120.png)

Forkjoin特点：工作窃取

能者多劳：线程不停滞

> Forkjoin

```java
ForkJoinPool.execute(ForkJoinTask task);
```

为异步执行给定任务的排列

```java
/**
 * 求和计算的任务！
 * 1.ForkJoin
 * 如何使用ForkJoinPool
 * ForkJoinPool.execute(ForkJoinTask task);
 * 计算类要继承RecursiveTask<>
 * <p>
 * 2.Stream并行流
 */
public class ForkJoinDemo extends RecursiveTask<Long> {

    private Long start;
    private Long end;

    private Long temp = 1000000L;

    public ForkJoinDemo(long start, long end) {
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if ((end - start) < temp) {
            Long sum = 0L;
            for (Long i = start; i <= end; i++) {
                sum += i;
            }
            return sum;
        } else {//forkjoin
            long middle = (start + end) / 2;//中间值
            ForkJoinDemo task1 = new ForkJoinDemo(start, middle);
            task1.fork();//拆分任务，把任务压入线程队列
            ForkJoinDemo task2 = new ForkJoinDemo(middle + 1, end);
            task2.fork();//拆分任务，把任务压入线程队列

            return task1.join() + task2.join();
        }
    }
}
```

```java
public class Test {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        test1();
        test2();
        test3();
    }

    //一般
    public static void test1(){
        long start =System.currentTimeMillis();
        Long sum=0L;
        for (int i = 1; i <= 10_0000_0000 ; i++) {
            sum+=i;
        }
        long end =System.currentTimeMillis();
        System.out.println("sum ="+sum+"  1时间:" +(end-start));
    }

    //ForkJoin
    public static void test2() throws ExecutionException, InterruptedException {
        long start =System.currentTimeMillis();

        ForkJoinPool forkJoinPool = new ForkJoinPool();
        ForkJoinTask<Long> task = new ForkJoinDemo(0L, 10_0000_0000L);
        ForkJoinTask<Long> submit = forkJoinPool.submit(task);// 提交任务
        Long sum = submit.get();

        long end =System.currentTimeMillis();
        System.out.println("sum ="+sum+"  2时间:" +(end-start));
    }

    //Stream并行流
    public static void test3(){
        long start =System.currentTimeMillis();

        long sum = LongStream.rangeClosed(0L, 10_0000_0000L).parallel().reduce(0, Long::sum);

        long end =System.currentTimeMillis();
        System.out.println("sum ="+sum+"  3时间:" +(end-start));
    }
}
```



# 15、异步回调

> Future 设计的初衷，对将来的某个事件的结果进行建模

```java
/**
 * 异步调用： CompletableFuture
 * // 异步执行
 * // 成功回调
 * // 失败回调
 */
public class Demo01 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //发起一个请求
        /*//没有返回值的异步回调
        CompletableFuture<Void> future = CompletableFuture.runAsync(()->{
            System.out.println(Thread.currentThread().getName()+"runAsync=>Void");
        });
        System.out.println("111");

        future.get();*/


        //有返回值的supplyAsync 异步回调
        //ajax，成功和失败的回调
        //返回的是错误信息
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(()->{
            System.out.println(Thread.currentThread().getName()+"supplyAsync=>Integer");
            //int i=1/0;//制造错误
            return 1024;
        });
        future.whenComplete((t,u)->{
            System.out.println(t);//正常的返回结果
            System.out.println(u);//错误信息
        }).exceptionally((e)->{
            System.out.println(e.getMessage());
            return 233;
        }).get();
    }
}
```



# 16、JMM

> 请你谈谈对Volatile的理解

Volatile 是 java虚拟提供的**轻量级的同步机制**

1. 保证可见性
2. ==不保证原子性==
3. 禁止指令重排



> 什么是JMM

JMM java内存模型 ，不存在的，概念！约定！



**关于JMM的一些同步的约定：**

1. 线程解锁前1，必须把共享变量==立刻==刷回主存
2. 线程家啊所欠，必须读取贮存种的最新值到工作内存中！
3. 加锁和解锁是同一把锁



线程 **工作内存、主内存**

8种操作

![image-20200716165632365](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200716165632365-1639131127603.png)

![image-20200716165818768](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200716165818768-1639131124503.png)

## 内存交互操作

 　内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）

- - lock   （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态
  - unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
  - read  （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
  - load   （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中
  - use   （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令
  - assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中
  - store  （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用
  - write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中

　　JMM对这八种指令的使用，制定了如下规则：

- - 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write
  - 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存
  - 不允许一个线程将没有assign的数据从工作内存同步回主内存
  - 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作
  - 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁
  - 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值
  - 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量
  - 对一个变量进行unlock操作之前，必须把此变量同步回主内存



# 17、Volatile

> 1.保证可见性

```java
public class JMMDemo {

    //不加volatile 程序死循环
    //加volatile 可以保证可见性
    private volatile static int num = 0;

    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            while (num == 0) { //对主内存线程的变化不知情

            }
        }).start();

        TimeUnit.SECONDS.sleep(1);

        num = 1; //上面线程没有知道num变化
        System.out.println(num);
    }
}
```



> 2.不保证原子性

原子性：不可分割

线程A在执任务的时候，不能被打扰的，也不能被分割，要么同时成功要么同时失败。

```java
//不保证原子性
public class VDemo2 {

    //volatile不保证原子性 synchronized可以
    private volatile static int num=0;

    public static void add(){
        num++;
    }

    public static void main(String[] args) {
        //理论应该num=2万
        for (int i = 1; i <=20 ; i++) {
            new Thread(()->{
                for (int j = 0; j < 1000; j++) {
                    add();
                }
            }).start();
        }

        while (Thread.activeCount()>2){//main gc
            Thread.yield();
        }

        System.out.println(Thread.currentThread().getName()+" "+num);
    }
}
```

**如果不加lock和synchronized ，怎么样保证原子性**



使用原子类、解决原子性问题

java.util.concurrent.atomic

- AtomicBoolean
- AtomicInteger
- AtomicLong等等

```java
//不保证原子性
public class VDemo2 {

    //原子类的Integer
    private volatile static AtomicInteger num=new AtomicInteger();

    public static void add(){
        num.getAndIncrement();//AtomicInteger +1 方法 CAS
    }

    public static void main(String[] args) {
        //理论应该num=2万
        for (int i = 1; i <=20 ; i++) {
            new Thread(()->{
                for (int j = 0; j < 1000; j++) {
                    add();
                }
            }).start();
        }

        while (Thread.activeCount()>2){//main gc
            Thread.yield();
        }

        System.out.println(Thread.currentThread().getName()+" "+num);
    }
}
```

这些类的底层都直接和操作系统挂钩！再内存中修改值！Unsafe类很特殊



> 指令重排

什么是指令重排：**写的程序，计算机并不是直接去执行**

源代码--> 编译器优化的重排-->指令并行也可能会重排-->内存系统也会重排--->执行

==处理器在进行指令重排的时候，考虑：数据之间的依赖性==

```java
int x = 1;//1
int y = 2;//2
x = x + 5;//3
y = x * x;//4

//应该是1234，但可能是2134，1324 不可能是4123！
```

可能造成影响的结果：a,b,x,y默认为0

| 线程A | 线程B |
| ----- | ----- |
| x=a   | y=b   |
| b=1   | a=2   |
|       |       |

正常的结果 x=0; y=0;



x和b无依赖性 可能由于指令重排

| 线程A | 线程B |
| ----- | ----- |
| b=1   | a=2   |
| x=a   | y=b   |

导致 x=2, y=1;



**voltile可以避免指令重排**

内存屏障、CPU指令。作用：

1. 保证特定的操作的执行顺序！
2. 可以保证某些变量的内存可见性（利用这些特性voltile实现了可见性）



# 18、彻底玩转单例模式

饿汉式、DCL懒汉式

```java
//饿汉式
public class Hungry {

    //可能会浪费空间
    private byte[] data1=new byte[1024*1024];
    private byte[] data2=new byte[1024*1024];
    private byte[] data3=new byte[1024*1024];
    private byte[] data4=new byte[1024*1024];

    private Hungry(){

    }

    private final static Hungry HUNGRY=new Hungry();

    public static Hungry getInstance(){
        return HUNGRY;
    }
}
```

```java
//懒汉式
// 道高一尺魔高一丈
public class Lazy {

    private static boolean aa=false;

    private Lazy() {
        synchronized (Lazy.class){
            if(aa==false){
                aa=true;
            }else {
                throw new RuntimeException("不要反射破坏单例！");

            }
        }
        System.out.println(Thread.currentThread().getName());
    }

    private volatile static Lazy lazy;

    public static Lazy getInstance() {
        if (lazy == null) {
            synchronized (Lazy.class) {
                if (lazy == null) {
                    lazy = new Lazy();//不是一个原子性操作
                    /**
                     * 1、分配内存空间
                     * 2.执行构造方法、促使话对象
                     * 3.把这个对象执行这个空间
                     *
                     * 123
                     * 132 A
                     *     B return 此时lazy还没有完成构造
                     */
                }
            }
        }
        return lazy;
    }

    //单线程下确实OK

    //多线程并发
    public static void main(String[] args) throws Exception {
        //Lazy instance = Lazy.getInstance();

        Field aa = Lazy.class.getDeclaredField("aa");
        aa.setAccessible(true);

        Constructor<Lazy> declaredConstructor = Lazy.class.getDeclaredConstructor();
        declaredConstructor.setAccessible(true);
        Lazy instance = declaredConstructor.newInstance();

        aa.set(instance,false);

        Lazy instance2=declaredConstructor.newInstance();
        System.out.println(instance==instance2);
    }
}
```

```java
//静态内部类
public class Holder {

    private Holder(){

    }

    public static Holder getInstance(){
        return InnerClass.HOLDER;
    }

    public static class InnerClass{
        private static final Holder HOLDER=new Holder();
    }
}
```

```java
// enum 是一个什么？ 本身也是一个Class类
public enum  EnumSingle {

    INSTANCE;

    public EnumSingle getInstance(){
        return INSTANCE;
    }

}

class Test{
    public static void main(String[] args) {
        EnumSingle enumSingle1=EnumSingle.INSTANCE;
        EnumSingle enumSingle2=EnumSingle.INSTANCE;

        System.out.println(enumSingle1==enumSingle2);

    }
}
```

```java
@CallerSensitive
public T newInstance(Object ... initargs)
    throws InstantiationException, IllegalAccessException,
           IllegalArgumentException, InvocationTargetException
{
    if (!override) {
        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
            Class<?> caller = Reflection.getCallerClass();
            checkAccess(caller, clazz, null, modifiers);
        }
    }
    if ((clazz.getModifiers() & Modifier.ENUM) != 0)
        throw new IllegalArgumentException("Cannot reflectively create enum objects");//枚举防反射 
    ConstructorAccessor ca = constructorAccessor;   // read volatile
    if (ca == null) {
        ca = acquireConstructorAccessor();
    }
    @SuppressWarnings("unchecked")
    T inst = (T) ca.newInstance(initargs);
    return inst;
}
```





# 19、深入理解CAS

> 什么是CAS

```java
public class CASDemo {
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(2020);

        /*
        期望，更新
        public final boolean compareAndSet(int expect, int update) {
            return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
            如果期望的值达到了，那么就会更新，否则就不更新
            CAS 是CPU的并发原语
        }*/
        atomicInteger.compareAndSet(2020,2021);//比较并交换！
        System.out.println(atomicInteger.get());//2021
        atomicInteger.compareAndSet(2020,2022);//比较并交换！
        System.out.println(atomicInteger.get());//没达到还是2021
    }
}
```

> Unsafe

![image-20200717144108537](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200717144108537-1639131121607.png)

![image-20200717144134701](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200717144134701-1639131117414.png)

var1:当前对象 var2：当前对象的内存地址  var4:1

var 5 =this.getIntVolatile(var1,var2);获取内存地址的值

this.compareAndSwapInt(var1,var2,var5,var5+var4);

如果内存地址的值 还是等于var5 就替换为var5+var4 也就是+1 ；不是就不加



CAS:比较当前内存中的值和主内存种的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环！

**缺点：**

1. 循环会耗时
2. 一次性只能保证一个共享变量的原子性
3. ABA问题



> CAS：ABA问题（狸猫换太子）

![image-20200717145139667](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200717145139667-1639131114573.png)

```java
public class CASDemo {
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(1);

        /*
        期望，更新
        public final boolean compareAndSet(int expect, int update) {
            return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
            如果期望的值达到了，那么就会更新，否则就不更新
            CAS 是CPU的并发原语
        }*/
        //对于我们平时写的SQL：乐观锁！
        //B 
        System.out.println(atomicInteger.compareAndSet(1, 3));
        System.out.println(atomicInteger.get());
        System.out.println(atomicInteger.compareAndSet(3, 1));
        System.out.println(atomicInteger.get());

        //A
        System.out.println(atomicInteger.compareAndSet(1, 3));
        System.out.println(atomicInteger.get());
    }
}
```





# 20、原子引用

带版本号的原子操作

> 解决ABA问题

```java
public class CASDemo {
    public static void main(String[] args) {
        //AtomicInteger atomicInteger = new AtomicInteger(1);
      
        AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(1,1);//值，版本号

        new Thread(()->{
            int stamp = atomicStampedReference.getStamp();//获得版本号
            System.out.println("a1 =>"+stamp);
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("a2 "+atomicStampedReference.compareAndSet(1, 3, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1));
            System.out.println("a2 =>"+atomicStampedReference.getStamp());

            System.out.println("a3 "+atomicStampedReference.compareAndSet(3, 1, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1));
            System.out.println("a3 =>"+atomicStampedReference.getStamp());
        },"a").start();

        //乐观锁的原理相同
        new Thread(()->{
            int stamp = atomicStampedReference.getStamp();
            System.out.println("b1 =>"+atomicStampedReference.getStamp());
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("b2 "+atomicStampedReference.compareAndSet(1, 6, stamp, stamp + 1));
            System.out.println("b2 =>"+atomicStampedReference.getStamp());
        },"b").start();
    }
}
```

如果泛型是一个包装类，注意引用问题
[]所有的相同类型的包装类对象之间值的比较，全部使用equals方法比较。
明:对于Integer var = ?在-128 至127之间的赋值，Integer 对象是在IntegerCache . cache产生,会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生,并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。



# 21、各种锁的理解

## 1、公平锁、非公平锁

公平锁：非常公平，不能插队，先来后到

非公平锁（默认）：非常不公平，可以插队

```java
public ReentrantLock() {//公平锁
    sync = new NonfairSync();
}
public ReentrantLock(boolean fair) {//true 非公平锁
    sync = fair ? new FairSync() : new NonfairSync();
}
```



## 2、可重入锁

可重入锁（递归锁）

**拿到外面的锁就可以拿里面的锁**

```java
//Synchronized
public class Demo1 {
    public static void main(String[] args) {
        Phone phone=new Phone();
        new Thread(()->{
            phone.sms();
        },"A").start();

        new Thread(()->{
            phone.sms();
        },"B").start();
    }
}

class Phone{
    public synchronized void sms(){
        System.out.println(Thread.currentThread().getName()+"sms");
        call();//这里也有锁
    }

    public synchronized void call(){
        System.out.println(Thread.currentThread().getName()+"call");

    }
}
```

```java
//lock
public class Demo2 {
    public static void main(String[] args) {
        Phone2 phone=new Phone2();
        new Thread(()->{
            phone.sms();
        },"A").start();

        new Thread(()->{
            phone.sms();
        },"B").start();
    }
}

class Phone2{
    Lock lock=new ReentrantLock();

    //sms和call是两把锁
    public void sms(){

        lock.lock();
        //锁必须配对，否则会死在里面
        try {
            System.out.println(Thread.currentThread().getName()+"sms");
            call();//这里也有锁 进入后并没有释放sms的锁 拿到了sms和call的锁
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }

    }

    public void call(){
        lock.lock();

        try {
            System.out.println(Thread.currentThread().getName()+"call");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```





##  3、自旋锁

spinlock

![image-20200717152848033](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200717152848033-1639131111433.png)



```java
/**
 * 自旋锁
 */
public class SpinlockDemo {

    AtomicReference<Thread> atomicReference=new AtomicReference<>();
    //加锁
    public void myLock(){
        Thread thread=Thread.currentThread();
        System.out.println(Thread.currentThread().getName()+"=> mylock");

        //自旋锁
        while(!atomicReference.compareAndSet(null,thread)){

        }
    }

    //解锁
    public void myUnlock(){
        Thread thread=Thread.currentThread();
        System.out.println(Thread.currentThread().getName()+"=> myUnlock");
        atomicReference.compareAndSet(thread,null);
    }
}
```

```java
public class TestSpinLock {
    public static void main(String[] args) {

        SpinlockDemo spinlockDemo=new SpinlockDemo();


        new Thread(()->{
            spinlockDemo.myLock();
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                spinlockDemo.myUnlock();
            }
        },"T1").start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            spinlockDemo.myLock();
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                spinlockDemo.myUnlock();
            }
        },"T2").start();



    }
}
```



![image-20200717160452815](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200717160452815-1639131108455.png)

T2自旋 T1解锁 T2才解锁 





## 4、死锁

![image-20200717160704214](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200717160704214-1639131104598.png)

死锁测试：如何排除

```java
public class DeadLockDemo {
    public static void main(String[] args) {
        String locka="loacka";
        String lockb="loackb";
        new Thread(new MyThread(locka,lockb),"T1").start();
        new Thread(new MyThread(lockb,locka),"T2").start();
    }
}

class MyThread implements Runnable{

    private String locka;
    private String lockb;

    public MyThread(String locka, String lockb) {
        this.locka = locka;
        this.lockb = lockb;
    }

    @Override
    public void run() {
        synchronized (locka){
            System.out.println(Thread.currentThread().getName()+"=>lock "+locka+"=>get "+lockb);
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            synchronized (lockb){
                System.out.println(Thread.currentThread().getName()+"=>lock "+lockb+"=>get "+locka);
                try {
                    TimeUnit.SECONDS.sleep(2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```



> jps

1. 使用`jps-l`定位进程号
2. jstack pid 
3. ![image-20200717164748322](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200717164748322-1639131100525.png)





