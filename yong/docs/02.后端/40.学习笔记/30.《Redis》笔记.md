---
title: 《Redis》笔记
date: 2021-05-26 15:59:49
permalink: /server/redis/
categories:
  - 后端
  - 学习笔记
tags:
  - 学习笔记
  - redis
---
# Redis



## Nosql概述

### 为什么要用Nosql

我们限制处理什么年代 2020年，大数据时代；

> 1、单机Mysql的时代

90年代，一个基本的网站访问量一般不会太大，单个数据库完全足够！

- 数据量如果太大：整个网站的瓶颈是什么？
- 数据的索引（B+Tree），一个机器的内存页放不下
- 访问量（读写混合），一个服务承受不了

>2、Memcached（缓存）+Mysql+垂直拆分（读写分离）

网站80%的情况都是在读数据，每次都要去查询数据库的话就会十分的麻烦，索引我们要减轻数据的压力，我们可以使用缓存

> 3、分库分表+水平拆分+Mysql集群

> 4、如今最近的年代

Mysql等关系型数据库就不够用了！，数据量很多，变化很快！

Mysql有的使用它储存一些比较大的文件，博客，图片！，数据表很大，效率就很低了！如果有一种数据库专门处理这种数据，mysql的压力就变得十分小，大数据的IO压力下，表几乎没法更改！

> 为什么要是有Nosql

用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长。

这时候我们就需要使用Nosql数据库的，nosql可以很好的处理以上的情况



### 什么是NoSql

> Nosql = Not Only SQL （不仅仅是SQL）

关系型数据库：表格，行，列（POI）

泛指非关系型数据库的，随着web2.0互联网的诞生！传统的关系型数据库很难对付web2.0时代！尤其超大规模的高并发的社区！暴露出来很多难以克服的问题，Nosql在当今大数据环境下发展的十分迅速，Redis是发展最快的，而且是我们当下必须掌握的技术！

很多的数据类型用户的个人信息，社交网络，地理位置。这些数据类型的储存不需要一个固定的格式！不需要多余的操作就可以横向扩展的！Map<String,Object> 键值对来控制



> Nosql 特点

解耦！

1. 方便扩展（数据之间没有关系，很好扩展!）
2. 大数据量高性能（Redis疫苗写8忘词，读取11万，Nosql的缓存记录级是一种细粒度缓存，性能会比较高！）
3. 数据类型是多样型的！（不需要实现设计数据库）
4. 传统的RDBMS和Nosql

```
传统的RDBMS
- 结构化组织
- SQL
- 数据和关系都存在单独的表中
- 数据定义语言
- 严格的一致性
- ..
```

```
Nosql
- 不仅仅是数据
- 没有固定的查询语言
- 键值对储存，列储存，文档储存，图形数据库（社交关系）
- 最终一致性
- CAP 定理和BASE 
- 高性能，高可用，高可扩
- ...
```



> 了解 3V+3高

 大数据时代的3V：

1. 海量Volume
2. 多样Variety
3. 实时Velocity

 互联网需求的3高：

1. 高并发
2. 高可拓
3. 高性能





### Nosql的四大分类

**KV键值对：**

- 新浪：Redis
- 美团：Redis+Tair
- 阿里、百度：Redis+memecache

**文档型数据库（bson可是和json一样）**

- MongoDB（一般必须要掌握）
  - MongoDB 是一个基于分布式文件储存的数据库，C++编写，主要用来处理大量的文档！
  - MongoDB 是一个介于关系型数据库和非关系型数据的中间产品！最想关系型数据库的非关系数据库（功能丰富）
- ConthDB



**列储存数据库**

- HBase
- 分布式文件系统



**图关系数据库**

- 他不是存图形，放的是关系，比如：朋友圈社交网络，广告推荐
- Neo4j，InfoGrid



> 四者对比

![image-20200526173218601](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200526173218601-1639133726112.png)





## Redis入门

### 概述

> Redis 是什么？

Redis (Remote Dictionary Server),远程字典服务

是一个开源的使用ANSI C语言编写、支持网络科技与内存亦可持久化的日志类型、key-value数据库、并提供多种语言的API，是诞下最热门的Nosql 技术之一！也被称之为结构化数据库



> Redis 能干吗

1. 内存储存、持久化，内存中是断电即失、索引持久化很重要（rdb，aof）
2. 效率高，可以用于高速缓存
3. 发布订阅系统
4. 地图信息分析
5. 计时器、计数器（浏览量！）
6. ...



> 特性

1. 多样的数据类型
2. 持久化
3. 集群
4. 事务
5. ...



http://www.redis.cn/ 中文官网



### Linux安装

1. 下载安装包`redis-6.0.3.tar.gz`

2. 解压Redis安装包！tar -zxvf redis-6.0.3.tar.gz

3. 进入解压后的文件，可以看到配置文件

   ![image-20200526180642391](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200526180642391-1639133721984.png)

4. 基本环境安装

   ```shell
   yum install gcc-c++
   
   make
   
   redis6.0+需要的gcc版本为5.3及以上，所以升级gcc即可
   
   //升级gcc到9以上
   yum -y install centos-release-scl
   yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils
   1
   2
   3
   还需要执行命令
   
   //临时将此时的gcc版本改为9
   scl enable devtoolset-9 bash
   //或永久改变
   echo "source /opt/rh/devtoolset-9/enable" >>/etc/profile
   ```

   

5. redis的默认安装路径`usr/local/bin`

6. 将redis配置文件，复制到我们的目录下

   ![image-20200526182734952](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200526182734952-1639133710088.png)

7. redis默认不是后台启动的，修改配置文件redis.conf

   ![image-20200526183029803](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200526183029803-1639133707007.png)

8. 通过指定的配置文件运行

   ![image-20200526185142127](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200526185142127-1639133704475.png)

9. 使用Redis客户端进行连接

   ![image-20200526185319462](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200526185319462-1639133701339.png)

10. 查看redis的进程是否开启

    ![image-20200526185453698](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200526185453698-1639133698733.png)

11. 如何关闭redis服务

    ![image-20200526185539450](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200526185539450-1639133696055.png)

    ![image-20200526185618867](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200526185618867-1639133694231.png)

12. 后面我们会使用单机多Redis启动集群测试！




### 测试性能

redis-benchmark是一个压力测试工具！

官方自带的性能测试工具！

![image-20200527152939406](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200527152939406-1639133690289.png)

我们来简单测试下：

```shell
#测试 100个并发连接 10000请求
redis-benchmark -h localhost -p 6379 -c 100 -n 100000
```

![image-20200527153531451](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200527153531451-1639133686436.png)

如何查看这些分析

![image-20200527154054228](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200527154054228-1639133682746.png)



### 基础的知识

redis默认有16个数据库

![image-20200527154815592](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200527154815592-1639133678359.png)

我们使用的是第0个

可以使用select进行切换数据库

![image-20200527154958554](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200527154958554-1639133674892.png)

```shell
select 3 #切换数据库
DBSIZE #查看数据库大小
keys * #查看数据库所有的key
FLUSHDB #清除当前数据库
FLUSHALL #清除所有数据库
```

为什么Redis是6379端口（粉丝效应）



> Redis是单线程的！

Redis是很快额，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络代管，既然可以使用单线程来实现，就使用单线程了！

Redis是C语言写的，官方提供的数据为10w+的QPS，网球不比Memecache差

**Redis为什么单线程还这么快？**

<font color=red>误区：</font>

1. 高性能的服务器一定是多线程的
2. 多线程（CPU上下文会切换）一定比单线程效率高



CPU>内存>硬盘的速度

核心：redis是将所有的数据全部放在内存中，所有说使用单线程去操作是最高的

多线程上下文切换会消耗时间，对于内存系统来说，没有上下文切换效率就是最高的！，多次读写都是在一个CPU上的，在内存情况下单线程是最佳的方案！





## 五大数据类型

> 官方文档

![image-20200527160345263](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200527160345263-1639133669856.png)

中文官网

![image-20200527160554587](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200527160554587-1639133664473.png)



### Redis-Key

```shell
127.0.0.1:6379> keys * #查看所有的key
127.0.0.1:6379> set name yong #set key
127.0.0.1:6379> EXISTS name #查看是否有这个key 
127.0.0.1:6379> move name #移除 key name 1代表当前数据库
127.0.0.1:6379> EXPIRE name 10 #10秒后 key name 会被删除 过期时间
127.0.0.1:6379> ttl name #查看当前key的剩余时间

127.0.0.1:6379> type name #查看key name 的类型

```

[官网命令](http://www.redis.cn/commands.html)







### String（字符串）

redis里存值会自动判断 可以加引号"",也可以不加

```shell
127.0.0.1:6379> set key1 yong #设置值
127.0.0.1:6379> get name #获取值
"yong"
127.0.0.1:6379> append name "aa" #追加字符串，如果key不存在，相当于set key
127.0.0.1:6379> strlen name  #获取字符串长度

127.0.0.1:6379> incr views #自增1
(integer) 2
127.0.0.1:6379> decr views #自减1
(integer) 1
127.0.0.1:6379> incrby views 10 #自增10 设置步长
(integer) 11
127.0.0.1:6379> decrby views 10 #自减10
(integer) 1
127.0.0.1:6379> 


127.0.0.1:6379> set key1 "hello,yong"
OK
127.0.0.1:6379> get key1 
"hello,yong"
127.0.0.1:6379> getrange key1 0 4 #截取字符串 0-4
"hello"
127.0.0.1:6379> getrange key1 0 -1 #截取所有字符串
"hello,yong"
127.0.0.1:6379> set key2 "abcdefg"
OK
127.0.0.1:6379> setrange key2 1 xx #替换指定位置字符串
(integer) 7
127.0.0.1:6379> get key2
"axxdefg"
127.0.0.1:6379> 

#setex(set with expire) #设置过期时间
#setnx(set if not exist) #不存在再设置（再分布式锁中常常使用）

127.0.0.1:6379> setex key3 30 "hello" #设置有效期30s
OK
127.0.0.1:6379> ttl key3 #查看剩余时间
(integer) 26
127.0.0.1:6379> get key3 #可以取到值
"hello"
127.0.0.1:6379> setnx mykey "redis"
(integer) 1
127.0.0.1:6379> get key3 #key3 过期
(nil)
127.0.0.1:6379> setnx mykey "MongDB" 
(integer) 0 #返回值0 设置失败
127.0.0.1:6379> get mykey
"redis" #值任然是redis
127.0.0.1:6379> 


#mset
#mget
127.0.0.1:6379> mset k1 v1 k2 v2 k3 v3 #设置多个值
OK
127.0.0.1:6379> keys *
1) "k1"
2) "k2"
3) "k3"
127.0.0.1:6379> mget k1 k2 k3 #获取多个值
1) "v1"
2) "v2"
3) "v3"
127.0.0.1:6379> msetnx k1 v1 k4 v4  #k1存在，一旦失败，后面都会失败
(integer) 0 #设置失败
127.0.0.1:6379> keys * #k4未设置
1) "k1"
2) "k2"
3) "k3"

#对象
set user:1{name:zhangsan,age:3} #设置user:1对象 值为json来保存

#这里的key是一个巧妙地设计：user:{id}:{filed},如此设计再Redis是完全OK的
127.0.0.1:6379> mset user:1:name zhangsan user:1:age 2
OK
127.0.0.1:6379> mget user:1:name user:1:age 
1) "zhangsan"
2) "2"


getset #先get 再 set

127.0.0.1:6379> getset db redis#先get 再 set
(nil) #不存在值返回null
127.0.0.1:6379> get db
"redis" #之前设置的redis值
127.0.0.1:6379> getset db "MongDB"
"redis" #先获取redis值，后设置MongDB
127.0.0.1:6379> get db 
"MongDB" #获取MongDB值

```

String类似的使用场景：value除了是我们的字符串还可以是数字

- 计数器
- 统计多单位数量





### List（链表）

基本的数据类型，列表

在redis里面，我们可以把list做出栈，队列，阻塞队列

```shell
127.0.0.1:6379> LPUSH list one #将一个值或者多个值，插入列表初始位置
(integer) 1
127.0.0.1:6379> LPUSH list two
(integer) 2
127.0.0.1:6379> LPUSH list three
(integer) 3
127.0.0.1:6379> LRANGE list 0 -1 #获取列表的所有值
1) "three"
2) "two"
3) "one"
127.0.0.1:6379> LRANGE list 0 1 #获取指定区间的值
1) "three"
2) "two"
127.0.0.1:6379> RPUSH list rrrrr #将一个值或者多个值，插入列表末尾位置
(integer) 4
127.0.0.1:6379> LRANGE list 0 -1
1) "three"
2) "two"
3) "one"
4) "rrrrr"
127.0.0.1:6379> LPOP list #移除初始位置的值
"three"
127.0.0.1:6379> RPOP list #移除末尾位置的值
"rrrrr"

LINDEX
127.0.0.1:6379> LRANGE list 0 -1
1) "two"
2) "one"
127.0.0.1:6379> LINDEX list 0 #获取指定下标的值
"two"
127.0.0.1:6379> LLEN list #获取list长度
(integer) 2
127.0.0.1:6379> Lpush list one #再添加一个one值
(integer) 3
127.0.0.1:6379> LRANGE list 0 -1
1) "one"
2) "two" 
3) "one"
127.0.0.1:6379> LREM list 1 two #移除一个two
(integer) 1
127.0.0.1:6379> LRANGE list 0 -1
1) "one"
2) "one"
127.0.0.1:6379> LREM list 2 one #移除2个one
(integer) 2
127.0.0.1:6379> LRANGE list 0 -1
(empty array)

trim 修剪
127.0.0.1:6379> lpush mylist "h1" "h2" "h3" "h4" #存多个值
(integer) 4
127.0.0.1:6379> lrange mylist 0 -1
1) "h4"
2) "h3"
3) "h2"
4) "h1"
127.0.0.1:6379> ltrim mylist 1 2 #截取下标[1,2]区间的值 
OK
127.0.0.1:6379> lrange mylist 0 -1 #列表只剩下截取的部分
1) "h3"
2) "h2"

rpoplpush #移除列表最后一个元素并添加到第一个位置

127.0.0.1:6379> lpush mylist "h1" "h2" "h3" "h4"
(integer) 4
127.0.0.1:6379> lrange mylist 0 -1
1) "h4"
2) "h3"
3) "h2"
4) "h1"
127.0.0.1:6379> rpoplpush mylist myotherlist #移除列表最后一个元素
"h1"                                         #添加到了目标list
127.0.0.1:6379> lrange mylist 0 -1 #查看原来的list
1) "h4"
2) "h3"
3) "h2"
127.0.0.1:6379> lrange myotherlist 0 -1 #查看目标list
1) "h1"


127.0.0.1:6379> exists list #判断列表是否存在
(integer) 0
127.0.0.1:6379> lset list 0 item #列表不存在不能set值
(error) ERR no such key
127.0.0.1:6379> lpush list v1 #列表第一个位置存v1值
(integer) 1
127.0.0.1:6379> lrange list 0 -1 #查看列表
1) "v1"
127.0.0.1:6379> lset list 0 item #修改列表第一个位置为item
OK
127.0.0.1:6379> lrange list 0 -1 #查看列表，修改成功
1) "item"


127.0.0.1:6379> lpush mylist hello world #列表存两个值hello，world
(integer) 2
127.0.0.1:6379> linsert mylist before "world" "beF" #在 world 前插入bef这个值
(integer) 3
127.0.0.1:6379> lrange mylist 0 -1 #查看列表元素
1) "beF"
2) "world"
3) "hello"
127.0.0.1:6379> linsert mylist after "world" "afT" #在 world 后插入afT这个值
(integer) 4
127.0.0.1:6379> lrange mylist 0 -1 #查看列表元素
1) "beF"
2) "world"
3) "afT"
4) "hello"

```

> 小结

- 实际上是一个链表,before Node after，left，right都可以插入值
- 如果key不存在，创建新的链表
- 如果key存在，新增内容
- 如果移除所有值，空链表，也代表不存在！
- 在两边插入值或者改动值，效率最高！中间元素相对较低~

消息排队！消息队列 lpush rpop ，栈lpush lpop





### Set（集合）

set中的值是不能重复的

无序不重复集合。抽随机

```shell
127.0.0.1:6379> sadd myset "hello" "yong" "world" #set存值
(integer) 3
127.0.0.1:6379> smembers myset #查看所有值
1) "yong"
2) "world"
3) "hello"
127.0.0.1:6379> sismember myset hello #查看是否存在hello值
(integer) 1
127.0.0.1:6379> scard myset #获取set集合元素个数
(integer) 3
127.0.0.1:6379> srem myset hello #移除hello元素
(integer) 1
127.0.0.1:6379> smembers myset #查看所有值
1) "yong"
2) "world"
127.0.0.1:6379> sadd myset v1 v2 v3 v4 v5 #多加几个值测试
(integer) 5
127.0.0.1:6379> smembers myset #查看所有值
1) "world"
2) "v2"
3) "v5"
4) "v1"
5) "yong"
6) "v4"
7) "v3"
127.0.0.1:6379> srandmember myset #随机取值
"v1"
127.0.0.1:6379> srandmember myset
"yong"
127.0.0.1:6379> srandmember myset
"world"
127.0.0.1:6379> srandmember myset 2 #随机2个值
1) "v1"
2) "yong"
127.0.0.1:6379> srandmember myset 2
1) "v5"
2) "yong"
127.0.0.1:6379> spop myset #随机删除元素
"v1"
127.0.0.1:6379> spop  myset #随机删除元素
"yong"

#将一个指定的值，移动到另外一个set集合中
127.0.0.1:6379> sadd myset hello world yong
(integer) 3
127.0.0.1:6379> sadd myset2 set2
(integer) 1
127.0.0.1:6379> smove myset myset2 yong #移动指定值
(integer) 1
127.0.0.1:6379> smembers myset
1) "world"
2) "hello"
127.0.0.1:6379> smembers myset2
1) "yong"
2) "set2"


127.0.0.1:6379> sadd set1 a b c d #set1元素 a b c d
(integer) 4
127.0.0.1:6379> sadd set2 c d e f #set2元素 c d e f
(integer) 4
127.0.0.1:6379> sdiff set1 set2 #set1跟set2的差集
1) "a"
2) "b"
127.0.0.1:6379> sinter set1 set2 #set1跟set2的交集
1) "d"
2) "c"
127.0.0.1:6379> sunion set1 set2 #set1跟set2的并集
1) "d"
2) "c"
3) "b"
4) "a"
5) "e"
6) "f"

```





### Hash（哈希）

Map集合，key-map！ 这个值是一个map集合

本质和String没有太大得区别

```shell
127.0.0.1:6379> hset myhash f1 a  #set 一个具体可key value
(integer) 1
127.0.0.1:6379> hmset myhash f1 a f2 b f3 c #set 多个kv
OK
127.0.0.1:6379> hget myhash f1 #获取字段值
"a"
127.0.0.1:6379> hmget myhash f1 f2 f3 #获取多个字段值
1) "a"
2) "b"
3) "c"
127.0.0.1:6379> hgetall myhash #获取全部得数据 
1) "f1"
2) "a"
3) "f2"
4) "b"
5) "f3"
6) "c"
127.0.0.1:6379> hdel myhash f1 #删除指定字段，对应value也没有了
(integer) 1
127.0.0.1:6379> hgetall myhash
1) "f2"
2) "b"
3) "f3"
4) "c"
127.0.0.1:6379> hlen myhash #获取字段数量
(integer) 2
127.0.0.1:6379> hexists myhash f1 #判断是否存在字段
(integer) 0
127.0.0.1:6379> hvals myhash #获取全部值
1) "b"
2) "c"
127.0.0.1:6379> hkeys myhash #获取全部key
1) "f2"
2) "f3"
127.0.0.1:6379> hset myhash f4 0
(integer) 1
127.0.0.1:6379> hincrby myhash f4 1 #自增1
(integer) 1
127.0.0.1:6379> hincrby myhash f4 -1 #hash没有decrby
(integer) 0
127.0.0.1:6379> hsetnx myhash f5 hello #如果存在设置失败，没有设置f5
(integer) 1


```

 

### Zset（有序集合）

在set的基础上，增加了一个值，set k1 v1 ------- zset k1 score1 v1

```shell
127.0.0.1:6379> zadd myset 1 one #添加一个值
(integer) 1
127.0.0.1:6379> zadd myset 2 two 3 three #添加多个值
(integer) 2
127.0.0.1:6379> zrange myset 0 -1 #获取所有值
1) "one"
2) "two"
3) "three"

#排序
127.0.0.1:6379> zadd salary 2500 xiaohong 
(integer) 1
127.0.0.1:6379> zadd salary 5000 zhangsan
(integer) 1
127.0.0.1:6379> zadd salary 10000 yong
(integer) 1
127.0.0.1:6379> zrangebyscore salary -inf +inf#-inf +inf代表负无穷到正无穷区间
1) "xiaohong"
2) "zhangsan"
3) "yong"
127.0.0.1:6379> zrangebyscore salary -inf +inf    #从小到大排序withscores#scores携带信息
1) "xiaohong"
2) "2500"
3) "zhangsan"
4) "5000"
5) "yong"
6) "10000"
127.0.0.1:6379> zrevrange salary 0 -1 withscores #从大到小排序
1) "yong"
2) "10000"
3) "zhangsan"
4) "5000"
5) "xiaoming"
6) "2500"

127.0.0.1:6379> zrangebyscore salary 0 (10000 #加括号代表 0<=x<10000 不加 0<=x<=10000 相当于不闭合区间 
127.0.0.1:6379> zrevrange salary 0 -1 withscores # 递减排列
1) "yong"
2) "10000"
3) "zhangsan"
4) "5000"
5) "xiaohong"
6) "2500"
127.0.0.1:6379> zrange salary 0 -1 withscores # 递增排列
1) "xiaohong"
2) "2500"
3) "zhangsan"
4) "5000"
5) "yong"
6) "10000"
127.0.0.1:6379> zrem salary xiaohong #移除元素
(integer) 1
127.0.0.1:6379> zrange salary 0 -1 withscores
1) "zhangsan"
2) "5000"
3) "yong"
4) "10000"
127.0.0.1:6379> zcard salary #获取集合元素个数
(integer) 2


127.0.0.1:6379> zadd myset 1 hello 2 world 3 yong
(integer) 3
127.0.0.1:6379> zcount myset 1 2 #获取指定区间成员数量
(integer) 2

```







## 三种特殊数据类型

### geospatial 地理位置

朋友的定位，附近的人，打车距离计算？

Redis 的 Geo 在 Redis3.2 版本就推出了！

这个共可以推算地理位置的信息，两地之间的距离，方圆几里的人！

可以查询一些测试数据http://www.jsons.cn/lngcode/

![image-20200528172318107](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200528172318107-1639133659392.png)



>geoadd

```shell
# geoadd 添加地理位置
# 武汉114.298572，30.584355 北京 116.405285，39.904989
# 添加城市数据 （两极无法添加）一般通过java程序一次性导入数据
# geoadd key 维度 经度 
127.0.0.1:6379> geoadd china:city 116.400 39.90 beijing
(integer) 1
127.0.0.1:6379> geoadd china:city 114.29 30.58 wuhan
(integer) 1
127.0.0.1:6379> geoadd china:city 121.47 31.23 shanghai
(integer) 1
127.0.0.1:6379> geoadd china:city 114.08 22.54 shenzhen
(integer) 1
127.0.0.1:6379> geoadd china:city 120.16 30.24 hangzhou
(integer) 1
127.0.0.1:6379> geoadd china:city 108.96 34.26 xian
(integer) 1

```

> geopos

```shell
127.0.0.1:6379> geopos china:city beijing #获取指定称视的经纬度
1) 1) "116.39999896287918091" #经度
   2) "39.90000009167092543"  #纬度
127.0.0.1:6379> geopos china:city wuhan
1) 1) "114.29000169038772583"
   2) "30.58000021509926825"

```

> geodist

两人之间的距离

单位：

- **m** 米
- **km** 千米
- **mi** 英里
- **ft** 英尺

```shell
127.0.0.1:6379> geodist china:city beijing wuhan #城市之间距离
"1054104.6973"
127.0.0.1:6379> geodist china:city beijing wuhan km #千米
"1054.1047" 
```



> georadius

我附近的人？（获得手机定位）通过半径查询

```shell
127.0.0.1:6379> georadius china:city 110 30 500 km #集合中查询
1) "xian"            #110经度 30维度 半径 500千米
2) "wuhan"
127.0.0.1:6379> georadius china:city 110 30 1000 km
1) "xian"
2) "shenzhen"
3) "wuhan"
4) "hangzhou"
127.0.0.1:6379> georadius china:city 110 30 1000 km withcoord count 2 #限制数量并携带信息
1) 1) "wuhan"
   2) 1) "114.29000169038772583"
      2) "30.58000021509926825"
2) 1) "xian"
   2) 1) "108.96000176668167114"
      2) "34.25999964418929977"

```



> georadiusbymember

根据成员元素半径查找

```shell
127.0.0.1:6379> georadiusbymember china:city wuhan 800 km
1) "wuhan"     #关于武汉周围800km城市
2) "hangzhou"
3) "shanghai"
4) "xian"
127.0.0.1:6379> georadiusbymember china:city wuhan 600 km
1) "wuhan"     #关于武汉周围600km城市
2) "hangzhou"

```



> geohash  返回一个或多个位置元素geohash表示

返回11个字符的geohash字符串，精度降低(不常用)

```shell
127.0.0.1:6379> geohash china:city wuhan beijing
1) "wt3mbwzmqj0"    #返回经纬度的字符串
2) "wx4fbxxfke0"    #如果两个字符串越接近，距离越近

```

> Geo 底层实现就是 Zset！ 我们可以通过Zset命令操作它

```shell
127.0.0.1:6379> zrange china:city 0 -1 #获取
1) "xian"
2) "shenzhen"
3) "wuhan"
4) "hangzhou"
5) "shanghai"
6) "beijing"
127.0.0.1:6379> zrem china:city beijing #删除
(integer) 1
127.0.0.1:6379> zrange china:city 0 -1 #获取
1) "xian"
2) "shenzhen"
3) "wuhan"
4) "hangzhou"
5) "shanghai"


```







### Hyperloglog

> 简介

Redis 2.8.9 版本就更新了Hyperloglog 数据结构

Redis Hyperloglog 技术统计的算法！

优点：占用内存固定 ，2^64 不同的元素的计数 ，只需要12KB

**网页的 UV （一个人访问一个网站多次还是算一个人）**

传统的方式，set保存用户的id，重复会被覆盖，统计元素数量作为标准

如果保存大量的用户id，就会比较麻烦！

我们目的是为了计数，而不是保存用户id；

从内存角度比较Hyperloglog首选（有0.81%错误率，忽略不计）

```shell
127.0.0.1:6379> pfadd mykey a b c d e f g #存多个值
(integer) 1
127.0.0.1:6379> pfcount mykey #获取数量
(integer) 7
127.0.0.1:6379> pfadd mykey2 e f g h i j k l #存多个值
(integer) 1
127.0.0.1:6379> pfcount mykey2 #获取数量
(integer) 8
127.0.0.1:6379> pfmerge mykey3 mykey mykey2 #去重整合mykey、mykey2
OK
127.0.0.1:6379> pfcount mykey3 #获取数量
(integer) 12

```

如果允许容错，那么一定可以使用Hyperloglog，否则使用set





### Bigmaps

> 位储存

Bitmap位图，数据结构！操作二进制位来进行记录，就只有0和1两个状态

365天 = 365 bit 1字节 = 8 bit 46 个字节左右

```shell
# 记录一周的打卡
127.0.0.1:6379> setbit sign 0 1  #0:周一 1:打卡
(integer) 0
127.0.0.1:6379> setbit sign 1 0  #0:周二 0:没有打卡
(integer) 0
127.0.0.1:6379> setbit sign 2 0  #0:周三 0:没有打卡
(integer) 0
127.0.0.1:6379> setbit sign 3 1  #0:周四 1:打卡
(integer) 0
127.0.0.1:6379> setbit sign 4 1  #0:周五 1:打卡
(integer) 0
127.0.0.1:6379> setbit sign 5 1  #0:周六 1:打卡
(integer) 0
127.0.0.1:6379> setbit sign 6 1  #0:周日 1:打卡
(integer) 0
# 查看打卡
127.0.0.1:6379> getbit sign 2 #周三没有打卡
(integer) 0
127.0.0.1:6379> getbit sign 6 #周日打卡
(integer) 1
# 统计打卡天数
127.0.0.1:6379> bitcount sign #一周5天打卡
(integer) 5

```



## 事务

Redis 事务本质：一组命令的集合

在事务执行的过程中，会按照顺序执行！一次性、顺序性、排他性

**Redis单条命令保存原子性，但是事务不保证原子性，没有隔离级别的概念**

redis的事务：

- **开启事务：**multi
- **命令入队：**执行命令语句
- **执行事务：**exec
- **放弃事务：**discard

> 正常执行事务！

```shell
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set k1 v1
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> get k2
QUEUED
127.0.0.1:6379> set k3 v3
QUEUED
127.0.0.1:6379> exec
1) OK
2) OK
3) "v2"
4) OK

```

> 放弃事务! discard 之前的命令语句不会执行





> 编译型异常（命令出错、代码出错），事务中所有命令不会被执行

```shell
127.0.0.1:6379> multi
OK
127.0.0.1:6379> getset k3 #错误语句
(error) ERR wrong number of arguments for 'getset' command
127.0.0.1:6379> set k1 v1 #未被执行
QUEUED
127.0.0.1:6379> exec
(error) EXECABORT Transaction discarded because of previous errors.
127.0.0.1:6379> get k1 #其他语句未被执行
(nil)

```



> 运行时异常（1/0）如果队列中存在语法性错误、其他命令会正常执行、错误命令抛出异常

```shell
127.0.0.1:6379> multi 
OK
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> incr k2 #字符串不能自增
QUEUED
127.0.0.1:6379> set k5 v5
QUEUED
127.0.0.1:6379> get k5
QUEUED
127.0.0.1:6379> exec #其他语句正常执行
1) OK
2) (error) ERR value is not an integer or out of range
3) OK
4) "v5"

```

> 监控！

**悲观锁：**

- 很悲观，认为什么时候都会出问题，无论做什么都加锁

**乐观锁：**

- 很乐观，认为什么时候都不会出问题，所以不会上锁，更新数据时去判断，在此期间是否有人修改过数据！
- 获取version
- 更新的时候比较version

Redis测试监视测试

```shell
# 正常执行成功
127.0.0.1:6379> set money 100
OK
127.0.0.1:6379> set out 0
OK
127.0.0.1:6379> watch money  #监视money对象
OK
127.0.0.1:6379> multi #数据期间没有发送变动
OK
127.0.0.1:6379> decrby money 20
QUEUED
127.0.0.1:6379> incrby out 20
QUEUED
127.0.0.1:6379> exec
1) (integer) 80
2) (integer) 20

```

```shell
127.0.0.1:6379> watch money
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> decrby money 10
QUEUED
127.0.0.1:6379> incrby out 10
QUEUED

##########另外一个客户端执行数据操作
127.0.0.1:6379> get money
"80"
127.0.0.1:6379> set money 200
OK
##########

127.0.0.1:6379> exec
(nil) #修改失败


127.0.0.1:6379> unwatch #之前的watch解除 旧version
OK
127.0.0.1:6379> watch money #要重新关注 version
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> decrby money 10
QUEUED
127.0.0.1:6379> incrby out 10
QUEUED
127.0.0.1:6379> exec #如果监视对象没有改变，执行成功
1) (integer) 190
2) (integer) 30


```







## Jedis

我们要使用java来操作Redis

>什么是Jedis 是Redis 官方推荐的java连接开放工具！使用java操作Redis中间件！

```shell

#取消conf中 requirepass foot 和 #bing 127.0.0.1的注释
[root@iZwz9ffkm6t8sepux4rpxuZ bin]# redis-cli -p 6379
127.0.0.1:6379> config get requirepass
(error) NOAUTH Authentication required.
127.0.0.1:6379> auth "redis-yong" #设置验证密码
OK
127.0.0.1:6379> config get requirepass #获取验证密码
1) "requirepass"
2) "redis-yong"
```



1、导入对应依赖

```xml
<!-- https://mvnrepository.com/artifact/redis.clients/jedis -->
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
    <version>3.3.0</version>
</dependency>

```

2、编码测试:

- 连接数据库
- 操作命令
- 断开连接

```java
public class TestPing {
    public static void main(String[] args) {
        //1、 new jedis 对象即可
        Jedis jedis = new Jedis("ip地址",6379);
        jedis.auth("redis-yong");
        //jedis 的所有命令就是我们之前学习的
        System.out.println("清空数据"+jedis.flushDB());
        System.out.println("判断某个键是否存在"+jedis.exists("username"));
        System.out.println("新增<'username','yong'>的键值对"+jedis.set("username","yong"));
        System.out.println("新增<'yong','yong'>的键值对"+jedis.set("yong","yong"));
        System.out.println("系统所有键如下:");
        Set<String> keys = jedis.keys("*");
        System.out.println(keys);
        System.out.println("删除键yong"+jedis.del("yong"));
        System.out.println("判断yong键是否存在"+jedis.exists("yong"));
        System.out.println("查看username所储存的类型"+jedis.type("username"));
        System.out.println("随即返回一个key"+jedis.randomKey());
        System.out.println("重命名key"+jedis.rename("username","name"));
        System.out.println("取出改后的name"+jedis.get("name"));
        System.out.println("按索引查询"+jedis.select(0));
        System.out.println("删除当前选择数控中的所有key"+jedis.flushDB());
        System.out.println("返回当前数据库中的key的数目"+jedis.dbSize());
        System.out.println("删除数据库中所有的key"+jedis.flushAll());
        System.out.println(jedis.ping());
    }
}

```



### 常用API

String 

List

Set

Hash

Zset

> 事务

```java
public class TestTX {
    public static void main(String[] args) {
        Jedis jedis = new Jedis("47.112.216.42",6379);
        jedis.auth("redis-yong");
        //开启事务
        JSONObject jsonObject=new JSONObject();
        jsonObject.put("hello","world");
        jsonObject.put("name","yong");
        Transaction multi = jedis.multi();
        try {
            String re = jsonObject.toJSONString();
            multi.set("user1",re);
            multi.set("user2",re);
            int i=1/0;
            multi.exec();//执行事务
        } catch (Exception e) {
            multi.discard();//放弃事务
            e.printStackTrace();
        } finally {
            System.out.println(jedis.get("user1"));
            System.out.println(jedis.get("user2"));
            jedis.close();//关闭连接
        }

    }
}
```





## SpringBoot 整合

SpringBoot操作数据：spring-data jpa jdbc mongodb redis！

SpringData也是和SpringBoot齐名的面古墓！

说明：在SpringBoot2.X之后，原来使用的jedis被替换为了lettuce

**jedis：**采用直连，多个线程操作的话，是不安全的，如果想要避免不安全，使用jedis pool连接池 BIO

**lettuce：**采用netty，实例可以在多个线程中进行共享，不存在线程不安全的清空！也可以减少线程数据了，更像NIO模式

源码分析：

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(RedisOperations.class)
@EnableConfigurationProperties(RedisProperties.class)
@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })
public class RedisAutoConfiguration {

   @Bean
   @ConditionalOnMissingBean(name = "redisTemplate")
    //我们可以自己定义一个redisTemplate来替换这个默认的
   public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory)
         throws UnknownHostException {
       //默认RedisTemplate没有过多的设置，redis对象都是序列化
       //两个泛型都是Obeject类型，我们使用需要强制转换<String,Object>
      RedisTemplate<Object, Object> template = new RedisTemplate<>();
      template.setConnectionFactory(redisConnectionFactory);
      return template;
   }

   @Bean
   @ConditionalOnMissingBean //由于String 是 redis中最常用的类型，所有单独提出来了一个bean
   public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory)
         throws UnknownHostException {
      StringRedisTemplate template = new StringRedisTemplate();
      template.setConnectionFactory(redisConnectionFactory);
      return template;
   }

}
```



> 整合测试

1、导入依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
#选中nosql  spring-boot-starter-data-redis
```

2、配置连接

```yaml
#配置redis
spring:
  redis:
    host: 47.112.216.42
    port: 6379
    password: redis-yong
```

3、测试

```java
@SpringBootTest
class Redis02SpringbootApplicationTests {

    @Autowired
    RedisTemplate  redisTemplate;

    @Test
    void contextLoads() {
        //redisTemplate.opsForValue();//操作字符串，类似String
        //redisTemplate.opsForList();//操作List，类似List
        //redisTemplate.opsForSet();//操作Set，类似Set
        //redisTemplate.opsForHash();//操作Hash，类似Hash
        //redisTemplate.opsForZSet();//操作ZSet，类似ZSet
        //除了基本的操作，我们常用的方法都可以通过redisTemplate直接操作，比如增删改查

        //获取连接对象
        //RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();
        //connection.flushDb();
        //connection.flushAll();

        redisTemplate.opsForValue().set("mykey","yong");
        redisTemplate.opsForValue().set("mykey2","勇");
        System.out.println(redisTemplate.opsForValue().get("mykey"));
        System.out.println(redisTemplate.opsForValue().get("mykey2"));
    }

}
```

![image-20200529190531289](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200529190531289-1639133637856.png)

![image-20200529190229050](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200529190229050-1639133624929.png)

![image-20200529190421674](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200529190421674-1639133622871.png)

直接传对象会报错，我们创建的对象需要实现序列化

我们编写一个字节RedisTemplate

```java
@Configuration
public class RedisConfig {

    //编写我们的redis模板
    @Bean
    public RedisTemplate<String,Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        //为了开发方便，使用<String,Object>
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(redisConnectionFactory);

        //序列化配置
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om=new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance , ObjectMapper.DefaultTyping.NON_FINAL);
        //om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL)
        jackson2JsonRedisSerializer.setObjectMapper(om);

        //String的序列化
        StringRedisSerializer stringRedisSerializer=new StringRedisSerializer();

        //key 采用String的序列化方式
        template.setKeySerializer(stringRedisSerializer);
        //hash 的key 采用String的序列化方式
        template.setHashKeySerializer(stringRedisSerializer);
        //value 采用String的序列化方式
        template.setValueSerializer(jackson2JsonRedisSerializer);
        //hash 的value 采用String的序列化方式
        template.setHashValueSerializer(jackson2JsonRedisSerializer);

        return template;
    }
}

```

![image-20200529194448279](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200529194448279-1639133618262.png)







## Redis.conf详解

启动的时候，就通过配置文件启动

> 单位

![image-20200530175605406](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200530175605406-1639133609719.png)

1. 配置文件 unit单位对大小写不敏感！

> 包含

![image-20200530175725466](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200530175725466-1639133604799.png)

就像学习Spring一样，可以包含其他配置文件

> 网络

> ![image-20200530180029735](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200530180029735-1639133602109.png)

> 通用 GENERAL

```shell
daemonize yes #已守护进程方式允许，默认no 我们需要开启为yes

pidfile /var/run/redis_6379.pid #如果以后台方式允许，我们就需要指定一个pid文件

日志
# Specify the server verbosity level.
# This can be one of:
# debug (a lot of information, useful for development/testing)
# verbose (many rarely useful info, but not a mess like the debug level)
# notice (moderately verbose, what you want in production probably)
# warning (only very important / critical messages are logged)
loglevel notice
logfile "" #日志得文件位置名
database 16 #数据库的数量 默认16
always-show-logo yes #是否总是显示logo
```

> 快照

持久化，在规定的时间内，执行了多少次擦欧总，则会持久化到文件.rdb .aof

redis 是内存数据库，如果没有持久化，那么断电数据即失

```shell
save 900 1 #如果900秒内，如果至少1个key进行了修改，执行持久化操作
save 300 10 #如果300秒内，如果至少10个key进行了修改，执行持久化操作
save 60 10000 #如果60秒内，如果至少10000个key进行了修改，执行持久化操作

#我们之后学习持久化，会自己定义这个测试

stop-writes-on-basave-error yes #持久化出错，是否需要继续工作
rdbcompression yes #是否压缩 rdb 文件，需要一些消耗cpu资源
rdbchecksum yes #保存rdb文件时，进行错误检查校验
dir ./ #rdb文件保存目录！
```

> REPLICATION 复制，我们后面讲解主从复制的





> SECURITY 安全

可以设置redis的密码，默认没有密码

```shell
config get requirepass #获取redis密码
config set requirepass "密码" #设置redis密码
auth "密码" #验证后可以继续操作
```

> Clients 限制

```shell
maxclients 10000 #设置连接上redis的最大客户端数量
maxmemory <bytes> #redis 默认最大内存容量 默认字节单位

maxmemory-policy noeviction #内存到达上限之后的处理策略 
1.volatile-lru:只对设置了过期时间的key进行LRU（默认）
2.allkeys-lru:删除lru算法的key
3.volatile-random:随机删除即将过期的key
4.allkeys-random:随机删除
5.volatile-ttl:删除即将过期的
6.noeviction:永不过期，返回错误

```

> APPEND ONLY 模式 aof配置

```shell
appendonly no #默认不开启aof模式，默认使用rdb持久化，大部分情况下rdb够用
appendfilename "appendonly.aof" #持久化文件的名字

# appendfsync always #每次修改都会 同步sync，消耗性能
appendfsync everysec #默认没有执行一次 sync 可能会丢失这1s的数据！
# appendfsync no #不执行同步，这个时候操作系统字节同步数据，速度最快
```





## Redis持久化

Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库装也会消失，所以Redis提供了持久化功能！



### RDB（Redis Database）

> 什么是RDB

在主从复制中，rdb就是备用，从机上面

![image-20200530185823433](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200530185823433-1639133556140.png)

在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，他恢复时将快照文件直接读到内存里。

Redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的回复，且对于数据恢复的完整性不是非常敏感，那莪RDB方式要比AOF方式更加高效。RDB的缺点是最后一次持久化后数据可能丢失。

==rdb保存的文件是 dumo.rdb，有时候会进行备份==

![image-20200530184140533](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200530184140533-1639133533996.png)

![image-20200530184252163](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200530184252163-1639133532239.png)

60s内修改5个key，触发rdb操作



> 触发机制

1. save的规则满足的清空下，会触发rdb规则
2. 执行了flush ，也会触发我们的rdb规则
3. 退出redis，也会产生rdb文件

备份就会自动生成一个dump.rdb

> 如何恢复rdb文件!

1. 只需要将rdb文件放在我们redis启动目录就可以，redis启动时会自动检测dump.rdb并恢复其中数据
2. 查看需要存在的位置
3. ![image-20200530185437083](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200530185437083-1639133526732.png)

- 优点
  - 适合大规模的数据恢复！
  - 如果你对数据完整性要求不高！
- 缺点
  - 需要一定的时间间隔！如果意外宕机，最后一次修改数据就没有了
  - fork进程的适合，会占用一定的内存空间





### AOF（Append Only File）

将我们的所有目录都记录下来，恢复的时候把这个文件全部在执行一遍！

![image-20200530191932406](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200530191932406-1639133522982.png)

以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从签到后执行一次完成数据的恢复工作

==AOF保存的时appendonly.aof文件==

> append

![image-20200530192319034](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200530192319034-1639133520357.png)

默认不开启，我们手动配置,只需要改为yes

重启shutdown就可以生效了



aof文件(记录了我们所有写操作) 有问题启动会失败

![image-20200530192917135](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200530192917135-1639133517724.png)

redis 给我们提供这样的工具`redis-check-aof --fix`

```shell
redis-check-aof --fix appendonly.aof
```

文件正常，重启就直接恢复了！

> 

```shell
appendonly no #默认不开启aof模式，默认使用rdb持久化，大部分情况下rdb够用
appendfilename "appendonly.aof" #持久化文件的名字

# appendfsync always #每次修改都会 同步sync，消耗性能
appendfsync everysec #默认没有执行一次 sync 可能会丢失这1s的数据！
# appendfsync no #不执行同步，这个时候操作系统字节同步数据，速度最快

重写规则说明
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb 
#如果aof文件大于64m，会新建一个新fork进程将我们的文件进行重写！
#aof默认就是文件的无限追加，文件会越来越大

```



- 优点
  - 每一次修改都同步，让文件的完整性更加好！
  - 每秒同步一次，可能会丢失一秒的数据
  - 从不同步，效率最高！
- 缺点
  - 相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢
  - aof允许效率也比rdb慢，所以edis默认配置时rdb



**扩展:**

1. RDB持久化方式能够在指定的时间间隔内对你的数据进行快照存储

2. AOF 持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据, AOF命令以Redis协议追加保存每次写的操作到文件末尾,Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。

3. 只做缓存,如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化

4. 同时开启两种持久化方式

   - 在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。
   - RDB的数据不实时,同时使用两者时服务器重启也只会找AOF文件,那要不要只使用AOF呢?作者建议不要,因为RDB更适合用于备份数据库( AOF在不断变化不好备份) , 快速重启,而且不会有AOF可能潜在的Bug ,留着作为一个万一的手段。

5. 性能建议

   - 因为RDB文件只用作后备用途,建议只在Slave.上持久化RDB文件,而且只要15分钟备份-次就够了,只保留save 900 1这条
     规则。
   - 如果Enable AOF ,好处是在最恶劣情况下也只会丢失不超过两秒数据,启动脚本较简单只load自己的AOF文件就可以了,代价一是带来了持续的I0 ,二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可,应该尽量减少AOF rewrite的频率, AOF重写的基础大小默认值64M太小了,可以设到5G以上,默认超过原大小100%大小重写可以改到适当的数值。
   - 如果不Enable AOF，仅靠Master-Slave Rellcation实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价时如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本页脚两个Master/SLAVE中的RDB文件，载入较新的那个，微博就是这种架构

   



## Redis发布订阅

Redis 发布订阅（pub/sub）是一种消息通信模式：发送者pub发送消息，订阅者sub接收消息

Redis 客户端可以订阅任意数量的频道

消息发送者--->频道--->接收者

![image-20200601124741888](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200601124741888-1639133512646.png)

关系

![image-20200601125044757](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200601125044757-1639133509179.png)

下表列出了 redis 发布订阅常用命令：

| 序号 | 命令及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | [PSUBSCRIBE pattern [pattern ...\]](https://www.runoob.com/redis/pub-sub-psubscribe.html) 订阅一个或多个符合给定模式的频道。 |
| 2    | [PUBSUB subcommand [argument [argument ...\]]](https://www.runoob.com/redis/pub-sub-pubsub.html) 查看订阅与发布系统状态。 |
| 3    | [PUBLISH channel message](https://www.runoob.com/redis/pub-sub-publish.html) 将信息发送到指定的频道。 |
| 4    | [PUNSUBSCRIBE [pattern [pattern ...\]]](https://www.runoob.com/redis/pub-sub-punsubscribe.html) 退订所有给定模式的频道。 |
| 5    | [SUBSCRIBE channel [channel ...\]](https://www.runoob.com/redis/pub-sub-subscribe.html) 订阅给定的一个或多个频道的信息。 |
| 6    | [UNSUBSCRIBE [channel [channel ...\]]](https://www.runoob.com/redis/pub-sub-unsubscribe.html) 指退订给定的频道。 |

测试

```shell
127.0.0.1:6379> subscribe yongyong #订阅频道
Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "yongyong"
3) (integer) 1
1) "message" #信息
2) "yongyong" #来自那个频道
3) "hello,yong" #具体消息

127.0.0.1:6379> publish yongyong "hello,yong" #频道发布信息
(integer) 1
127.0.0.1:6379> 


```



> 原理

Redis是使用C实现的,通过分析Redis源码里的pubsub.c.文件,了解发布和订阅机制的底层实现,籍此加深对Redis的理解。

Redis通过PUBLISH、SUBSCRIBE 和PSUBSCRIBE等命令实现发布和订阅功能。

通过SUBSCRIBE命令订阅某频道后, redis-server里维护了-一个字典，字典的键就是一个个channel（频道） , 而字典的值则是-个链表,链表中保存了所有订阅这个channel的客户端。SUBSCRIBE 命令的关键,就是将客户端添加到给定channel的订阅链表中。

通过PUBLISH命令向订阅者发送消息, redis-server 会使用给定的频道作为键,在它所维护的channel字典中查找记录了订阅这个频道的所有客户端的链表,遍历这个链表,将消息发布给所有订阅者。

Pub/Sub从字面上理解就是发布( Publish )与订阅( Subscribe) , 在Redis中,你可以设定对某一-个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后,所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统,比如普通的即时聊天,群聊等功能。





## 主从复制

### 概念

主从复制,是指将一台Redis服务器的数据 ,复制到其他的Redis服务器。前者称为主节点(master/leader) ,后者称为从节点(slave/follower) ;数据的复制是单向的,只能由主节点到从节点。Master以写为主 , Slave以读为主。

默认情况下,每台Redis服务器都是主节点;且一个主节点可以有多个从节点(或没有从节点) ,但-个从节点只能有一个主节点。主从复制的作用主要包括:

1、数据冗余:主从复制实现了数据的热备份,是持久化之外的一种数据冗余方式。

2、故障恢复:当主节点出现问题时,可以由从节点提供服务,实现快速的故障恢复;实际上是一种服务的冗余。

3、负载均衡:在主从复制的基础上,配合读写分离,可以由主节点提供写服务,由从节点提供读服务(即写Redis数据时应用连接主节点,读Redis数据时应用连接从节点) , 分担服务器负载;尤其是在写少读多的场景下,通过多个从节点分担读负载,可以大大提高Redis服务器的并发量。

4、高可用（集群）基石:除了上述作用以外,主从复制还是哨兵和集群能够实施的基础,因此

说主从复制是Redis高可用的基础。一般来说,要将Redis运用于工程项目中,只使用一台Redis是万万不能的,原因如下:

1、从结构上,单个Redis服务器会发生单点故障,并且一 台服务器需要处理所有的请求负载,压力较大;

2、从容量上,单个Redis服务器内存容量有限,就算一台Redis服务器内存容 量为256G ,也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G



主从复制，读写分离！80%都是在进行读操作，减缓服务器的压力！架构中经常使用



### 环境配置

只配置从库，不配置主库！

```shell
127.0.0.1:6379> info replication # 查看当前库的信息
# Replication
role:master #角色 master
connected_slaves:0 # 没有从机
master_replid:a0b366ba19bb17327af9edfcb70aeca780465b6c
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
master_repl_meaningful_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0

```

复制配置文件，修改配置

1. 端口
2. pid名字
3. log文件名字
4. dump.rdb名字
5. 启动测试（一主一从）

![image-20200601132744113](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200601132744113-1639133505393.png)





## 一主二从

默认情况下，每台Redis服务器都是主节点；我们一般情况下只用配置从机就好了

```shell
主机（6379） 从机（6380）（6381）

127.0.0.1:6380> slaveof 127.0.0.1 6379 #认老大 从机配置主机
OK
127.0.0.1:6380> info replication #打印信息
# Replication
role:slave #角色从i
master_host:127.0.0.1 #主机地址
master_port:6379 #主机端口
master_link_status:up
master_last_io_seconds_ago:1
master_sync_in_progress:0
slave_repl_offset:14
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:01ad28bd57429084225622ba289c0fad5c0c897e
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:14
master_repl_meaningful_offset:0
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:14


127.0.0.1:6379> info replication #打印信息
# Replication
role:master #角色 主机
connected_slaves:1 #从机一个
slave0:ip=127.0.0.1,port=6380,state=online,offset=28,lag=0
master_replid:01ad28bd57429084225622ba289c0fad5c0c897e
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:28
master_repl_meaningful_offset:0
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:28

```

真实的主从配置应该在配置文件中配置，这样的话是永久的，命令是暂时的

```shell
配置文件 开启
# replicaof <主机ip> <主机端口>
# masterauth 主机认证密码

```



> 细节

主机负责写，从机负责读！主机中的所有信息和数据都会被从机储存

==从机是不能写数据的==

测试：主机断开连接，从机依旧连接主机，但是没有写操作，如果主机重连，从机依旧可以获取主机写的新信息

如果是使用命令行配置的主从关系，从机断开在连接，会失去之前的主从关系，需要再次命令行配置主从，数据会立马从主机中获取到



> 复制原理

Slave 启动成功连接到master后会发送一个sync同步命令

Master 接到命令，启动后台的存盘进程，同时手机所有接收到的用于修改数据集的命令，在后台进程执行完毕之后，==master将传送整个数据文件到slave，并完成一次完全同步。==

全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中

增量复制：Master 继续将新的所有收集到的修改命令一次传给slave，完成同步

但是只要是重新连接master，一尺完全同步（全量复制）将被自动执行



> 层层主从

除了首尾，每个节点都是上个节点的从机，下个节点的主机



> 如果主机没了，这时候能不能选择一个主机来呢

如果主机断开来凝结，我们可以手动`slaveof no one`让自己变成主机！其他节点就可以手动连接到最新的这个主节点，但全部为手动



### 哨兵模式（自动选择主机）

> 概述

主从切换的方法是：当主机服务器宕机后，需要手动一台从机切换成主机服务器，这需要人工干预，费时费力，还会造成一段时间内服务不可用，所有更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵）架构来解决这个问题

哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，他会独立运行，原理是**哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例**。

![image-20200601140945876](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200601140945876-1639133501747.png)

这里哨兵有两个作用：

- 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器
- 当哨兵检测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让他们切换主机

然而一个哨兵进程对Redis服务器进行监控，可能会出现为问题，为此我们可以使用多个哨兵进行监控，各个哨兵还会互相监控，这就形成了多哨兵模式。

![image-20200601141305795](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200601141305795-1639133498133.png)

假设主服务器宕机，哨兵1先检测到这个结果，系统不会马上进行failover过程，仅仅是哨兵1主管认为这个服务器不可用，这个现象为**主观下线**。当给后面的哨兵也检查到主服务器不可用，并且数量达到一定值时，那么哨兵间会进行一次投票，投票结果由一个哨兵发起，进行failover故障转移操作，切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现且换主机，这个过程成为**客观下线**



> 测试

配置哨兵文件sentinel.conf  

```shell
# sentinel monitor 被监控名称 host port 1（代表主机挂了，从机投票） 
sentinel monitor myredis 127.0.0.1 6379 1
~          
```

启动哨兵

```shell
[root@iZwz9ffkm6t8sepux4rpxuZ bin]# redis-sentinel myconfig/sentinel.conf
11574:X 01 Jun 2020 14:26:22.763 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
11574:X 01 Jun 2020 14:26:22.763 # Redis version=6.0.3, bits=64, commit=00000000, modified=0, pid=11574, just started
11574:X 01 Jun 2020 14:26:22.763 # Configuration loaded
                _._                                                  
           _.-``__ ''-._                                             
      _.-``    `.  `_.  ''-._           Redis 6.0.3 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._                                   
 (    '      ,       .-`  | `,    )     Running in sentinel mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 26379
 |    `-._   `._    /     _.-'    |     PID: 11574
  `-._    `-._  `-./  _.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |           http://redis.io        
  `-._    `-._`-.__.-'_.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |                                  
  `-._    `-._`-.__.-'_.-'    _.-'                                   
      `-._    `-.__.-'    _.-'                                       
          `-._        _.-'                                           
              `-.__.-'                                               

11574:X 01 Jun 2020 14:26:22.764 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
11574:X 01 Jun 2020 14:26:22.767 # Sentinel ID is 8fdec8ebebed9cd4736f4fb35e650de382c6ce30
11574:X 01 Jun 2020 14:26:22.767 # +monitor master myredis 127.0.0.1 6379 quorum 1

```



==主机重连会变成从机==

> 哨兵模式

优点：

- 哨兵集群，基于主从复制
- 主从可以切换，故障可以转移，系统可用性好
- 哨兵模式就是主从模式的升级，自动切换

缺点：

- Redis 不好在线扩容，集群容量一旦到达上限，在线扩容就十分麻烦
- 实现哨兵模式的配置很麻烦，里面有很多选择

> 哨兵模式的全部配置

```shell
# Example sentine1. conf
#哨兵sentine1实例运行的端口默认26379
port 26379
#哨兵sentine1的工作目录
dir /tmp
I
#哨兵sentine1监控的redis主节点的ip port
# master-name
可以自己命名的主节点名字只能由字母A-z、数字0-9、这三个字符".- "组成。
# quorum配置多少个sentine1哨兵统- -认为master主节点失联那么这时客观上认为主节点失联了
牛sentine1 monitor <master-name> < <ip> <redis-port> <quorum>
sentine1 monitor mymaster 127.0.0.1 6379 2
#当在Redis实例中开启 了requirepass foobared授权密码这样所有连接Redi s实例的客户端都要提供密码
#设置哨兵sentinel 连接主从的密码注意必须为主从设置-样的验证密码
#sentinel auth-pass <master-name> <password>
sentine1 auth-pass mymaster MySUPER--secret-0123password

#指定多少亳秒之后主节点没有应答哨兵sentinel此时哨兵主观上认为主节点下线默认30秒
# sentine1 down-after-milliseconds <master-name> <mi 11iseconds>
sentine1 down-after-milliseconds mymaster 30000
#这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行同步，
这个数字越小，完成failover所需的时间就越长，
但是如果这个数字越大，就意味着越多的slave因为replicati on而不可用。
可以通过将这个值设为1来保证每次只有一个slave处于不能处理命令请求的状态。
# sentine1 para1le1-syncs <master-name> <nums laves>
sentine1 parallel-syncs mymaster 1
#故障转移的超时时间fai lover-timeout可以用在以下这些方面:
#1.同一个sentine1对同一 个master两次failover之间的间隔时间。
#2.当一个s1ave从一 个错误的master那里同步数据开始计算时间。直到s lave被纠正为向正确的master那里同步数据时。
#3.当想要取消一个正在进行的failover所需要的时间。
#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves 依然会被正确配置为指向
master,但是就不按paral1e1-syncs所配置的规则来了
#默认三分钟
# sentine1 failover-timeout <master-name> <milliseconds>
sentine1 failover-ti meout mymaster 180000


# SCRIPTS EXECUTION
#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。
#对于脚本的运行结果有以下规则:
#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10
#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。
#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。
#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被-一个SIGKILL信 号终止，之后重新执行。
#通知型脚本:当sentine1有任何警告级别的事件发生时( 比如说redis实例的主观失效和客观失效等等)，将会去调用这个脚本，这时这个
脚本应该通过邮件，SMS 等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，- - 个是事件的类型，一
个是事件的描述。如果sentine1. conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则
sentine1无法正常启动成功。
#通知脚本
# she11编程
# sentine1 notificati on-script <master-name> <script-path>
sentine1 notification-script mymaster /var/redis/notify. sh

#客户端重新配置主节点参数脚本
#当一个master由于failover而发生改变时， 这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。
#以下参数将会在调用脚本时传给脚本:
# <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port>
#目前<state> 总是"“failover”,
# <role>是“1eader"或者“observer”中的一个。
#参数from-ip，from-port， to-ip， to-port是用来和旧的master和新的master (即旧的slave)通信的
#这个脚本应该是通用的，能被多次调用，不是针对性的。
# sentine1 client-reconfig-script <master-name> <script-path>
sentine1 client-reconfig-script mymaster /var/redis/reconfig. sh #一般都是由运维来配置
```





## Redis缓存穿透和雪崩

Redis缓存的使用，极大的提升了应用程序的性能和效率，特别熟数据查询方面。但同时，他也带来了一些问题。其中，最要害的问题，就是数据一致性问题，从严格意义上来讲，这个问题无解，如果对数据的一致性要求很高，那么就不能使用缓存。

另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也有比较流行的解决方案



### 缓存穿透

> 概念

比如，用户想要查询一个数据，发现redis内存数据没有，也就是缓存没有命中，于是像持久层数据库拆线呢。发现也没有，于是本次拆线呢失败，当用户很多的时候，缓存都没有命中，于是都去请求持久层数据库，这会给持久层数据库造成很大的压力，这时候相当于出现了缓存穿透。



> 解决方案

**布隆过滤器**

布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式储存，在控制从先进性校验，不符合则丢弃，从而避免了对底层储存系统的查询压力：

![image-20200601145234156](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200601145234156-1639133495468.png)

**缓存空对象**

当储存层不命中后，解释返回空对象也将其缓存起来，同时会设置一个过期时间，之后在访问这个数据会从缓存中获取，保护了后端数据源

![image-20200601145433695](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200601145433695-1639133492297.png)

但是这种方法会存在两个问题：

- 如何空值被缓存起来，意味着需要更多空间储存更多的键，因为这当中很多可能为空值的键
- 即使对空值设置了过期时间，还是会存在缓存和储存层的数据有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响



### 缓存击穿

> 概述

是指一个key非常热点，在不停的进行大并发，大并发集中对这个一点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像凿开了一个洞

当某个key在过期的瞬间，有大量请求并访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且会写混村，会导致数据库瞬间压力过大

> 解决方案

**设置热点数据永不过期**

从缓存层面来看，没有设置过期使劲啊，所有不会出现热点key过期后产生的问题

**加互斥锁**

分布式锁：使用分布式锁，保证对于每个key同时只要一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可，这种方式将高并发的要转移到分布式锁，因此对分布式锁的考验很大



### 缓存雪崩

> 概念

缓存雪崩是指某个时间段内，缓存集中过期失效。或者Redis 宕机

产生雪崩的原因之一，比如写文本的时候，马上就到到双十二0点，就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个i下凹式，那么到了凌晨一点的后悔，这批商品的缓存就都过期了，而对这批商品的查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到储存层，储存层的调用量会暴增，造成储存层也会挂掉的情况。

![image-20200601150942225](https://gitee.com/yong-forever/image_store/raw/master/utools/image-20200601150942225-1639133487443.png)

其实集中过期,倒不是非常致命,比较致命的缓存雪崩,是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩,一定是在某个时间段集中创建缓存,这个时候,数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机,对数据库服务器造成的压力是不可预知的,很有可能瞬间就把数据库压垮。

> 解决方案

**redis高可用**

这个思想的含义是,既然redis有可能挂掉,那我多增设几台redis ,这样一台挂掉之 后其他的还可以继续工作,其实就是搭建的集群。

**限流降级**

这个解决方案的思想是,在缓存失效后,通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存,其他线程等待。

**数据预热**

数据加热的含义就是在正式部署之前,我先把可能的数据先预先访问一遍,这样部分可能大量访问的数据就会加载到缓存中。在即将发送大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀